#!/usr/bin/env node
/**
 * Simply MCP Builder
 *
 * An MCP server that teaches LLMs how to build MCP servers.
 * Provides step-by-step instructions and reference resources.
 *
 * Usage case: When a user asks an LLM to convert an API/class to MCP
 * or build an MCP server from scratch, this server provides the guidance.
 */

import * as fs from 'fs';
import * as path from 'path';
import { IPrompt, IResource, IServer } from './src/server/interface-types';

// =============================================================================
// QUICK REFERENCE RESOURCES (Inline Content)
// =============================================================================

const QUICK_REFS = {
  'tool-patterns': `# Common Tool Patterns

## CRUD Operations
\`\`\`typescript
interface CreateUserTool extends ITool {
  name: 'create_user';
  description: 'Create a new user';
  params: {
    username: string;
    email: string;
  };
  returns: { id: string; username: string };
  async execute(params) {
    // Implementation
    return { id: '123', username: params.username };
  }
}
\`\`\`

## Search/Query
\`\`\`typescript
interface SearchTool extends ITool {
  name: 'search';
  description: 'Search for items';
  params: {
    query: string;
    limit?: number;
  };
  returns: Array<{ id: string; name: string }>;
  async execute(params) {
    // Implementation
    return [];
  }
}
\`\`\`

## Transform/Process
\`\`\`typescript
interface TransformTool extends ITool {
  name: 'transform_data';
  description: 'Transform data format';
  params: {
    input: string;
    format: 'json' | 'xml' | 'csv';
  };
  returns: string;
  async execute(params) {
    // Implementation
    return params.input;
  }
}
\`\`\`

## Validation/Check
\`\`\`typescript
interface ValidateTool extends ITool {
  name: 'validate';
  description: 'Validate input';
  params: {
    data: string;
  };
  returns: { valid: boolean; errors?: string[] };
  async execute(params) {
    // Implementation
    return { valid: true };
  }
}
\`\`\``,

  'resource-patterns': `# Common Resource Patterns

## Static Configuration
\`\`\`typescript
interface ConfigResource extends IResource {
  uri: 'config://settings';
  name: 'Application Settings';
  description: 'Current configuration';
  mimeType: 'application/json';
  text: JSON.stringify({
    apiUrl: 'https://api.example.com',
    version: '1.0.0'
  }, null, 2);
}
\`\`\`

## Dynamic Stats
\`\`\`typescript
interface StatsResource extends IResource {
  uri: 'stats://current';
  name: 'Current Statistics';
  description: 'Real-time stats';
  mimeType: 'application/json';
  returns: 'text';
  async text() {
    const stats = {
      uptime: process.uptime(),
      memory: process.memoryUsage()
    };
    return JSON.stringify(stats, null, 2);
  }
}
\`\`\`

## Log/History
\`\`\`typescript
interface LogResource extends IResource {
  uri: 'logs://recent';
  name: 'Recent Logs';
  description: 'Last 100 log entries';
  mimeType: 'text/plain';
  returns: 'text';
  async text() {
    // Read from log file or array
    return logs.join('\\n');
  }
}
\`\`\`

## Data List
\`\`\`typescript
interface DataResource extends IResource {
  uri: 'data://users';
  name: 'User List';
  description: 'All users';
  mimeType: 'application/json';
  returns: 'text';
  async text() {
    const users = await db.query('SELECT * FROM users');
    return JSON.stringify(users, null, 2);
  }
}
\`\`\``,

  'prompt-patterns': `# Common Prompt Patterns

## Generate Content
\`\`\`typescript
interface GeneratePrompt extends IPrompt {
  name: 'generate';
  description: 'Generate content based on template';
  args: {
    type: string;
    context: string;
  };
  template: \`Generate a {type} based on: {context}\`;
}
\`\`\`

## Transform/Convert
\`\`\`typescript
interface ConvertPrompt extends IPrompt {
  name: 'convert';
  description: 'Convert between formats';
  args: {
    from: string;
    to: string;
    content: string;
  };
  template: \`Convert this {from} to {to}:\\n{content}\`;
}
\`\`\`

## Analyze/Review
\`\`\`typescript
interface AnalyzePrompt extends IPrompt {
  name: 'analyze';
  description: 'Analyze code or text';
  args: {
    content: string;
    focus?: string;
  };
  template: \`Analyze this code{focus ? \` focusing on \${focus}\` : ''}:\\n{content}\`;
}
\`\`\`

## Dynamic Prompt with Logic
\`\`\`typescript
interface SmartPrompt extends IPrompt {
  name: 'smart_prompt';
  description: 'Dynamic prompt generation';
  args: { mode: string; data: string };
  returns: 'messages';
  async messages(args) {
    const prompt = args.mode === 'simple'
      ? \`Simple analysis: \${args.data}\`
      : \`Detailed analysis: \${args.data}\`;
    return [{ role: 'user', content: { type: 'text', text: prompt } }];
  }
}
\`\`\``,

  'validation-cheatsheet': `# IParam Validation Cheat Sheet

## String Validation
\`\`\`typescript
params: {
  // Email
  email: IParam<string> & { format: 'email' };

  // URL
  url: IParam<string> & { format: 'url' };

  // Pattern (regex)
  username: IParam<string> & { pattern: '^[a-zA-Z0-9_]+$' };

  // Length constraints
  password: IParam<string> & { minLength: 8; maxLength: 100 };
}
\`\`\`

## Number Validation
\`\`\`typescript
params: {
  // Range
  age: IParam<number> & { minimum: 0; maximum: 150 };

  // Positive only
  count: IParam<number> & { minimum: 1 };

  // With exclusions
  score: IParam<number> & { minimum: 0; maximum: 100; exclusiveMaximum: true };
}
\`\`\`

## Enum/Union
\`\`\`typescript
params: {
  // String enum
  status: 'active' | 'inactive' | 'pending';

  // Number enum
  priority: 1 | 2 | 3 | 4 | 5;
}
\`\`\`

## Optional Parameters
\`\`\`typescript
params: {
  required: string;
  optional?: string;
  withDefault?: number; // Can provide default in execute
}
\`\`\`

## Complex Types
\`\`\`typescript
params: {
  // Array
  tags: string[];

  // Object
  metadata: { key: string; value: string };

  // Nested
  config: {
    host: string;
    port: number;
    options?: { timeout: number };
  };
}
\`\`\``,

  'conversion-guide': `# API/Class → MCP Conversion Guide

## Step-by-Step Checklist

### 1. Analyze the Source
- [ ] List all public methods/functions
- [ ] Identify input parameters and types
- [ ] Identify return types
- [ ] Note any async operations
- [ ] Check for configuration/state

### 2. Map to MCP Interfaces

**Methods → ITool**
- Method name → tool name (convert to snake_case)
- Method params → ITool params
- Method return → ITool returns
- Method body → execute()

**Configuration → IResource**
- Config object → Static resource with JSON
- State/data → Dynamic resource with text()

**Templates → IPrompt**
- If API does text generation → IPrompt with template
- If API has input patterns → IPrompt with args

### 3. Conversion Examples

**REST API Method:**
\`\`\`typescript
// Original REST
POST /api/users
Body: { username, email }
Response: { id, username, email, createdAt }

// MCP Tool
interface CreateUserTool extends ITool {
  name: 'create_user';
  description: 'Create a new user';
  params: { username: string; email: string };
  returns: { id: string; username: string; email: string; createdAt: string };
  async execute(params) {
    const response = await fetch('https://api.example.com/api/users', {
      method: 'POST',
      body: JSON.stringify(params)
    });
    return await response.json();
  }
}
\`\`\`

**Class Method:**
\`\`\`typescript
// Original Class
class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }
}

// MCP Tool
interface AddTool extends ITool {
  name: 'add';
  description: 'Add two numbers';
  params: { a: number; b: number };
  returns: number;
  execute(params) {
    return params.a + params.b;
  }
}
\`\`\`

### 4. Handle Special Cases

**Authentication:**
- Use IApiKeyAuth for HTTP mode
- Store API keys in environment variables
- Pass credentials in execute()

**State Management:**
- Store instance state outside interfaces
- Use closures or module-level variables
- Expose state via IResource

**Error Handling:**
- Wrap API calls in try/catch
- Throw descriptive errors
- Return error objects in returns type if needed

### 5. Testing
- [ ] Run: \`simply-mcp run --dry-run server.ts\`
- [ ] Verify all interfaces discovered
- [ ] Test each tool manually
- [ ] Check resource URIs are valid
- [ ] Validate prompt templates`
};

// =============================================================================
// HELPER: Load File Content
// =============================================================================

function loadFile(relativePath: string): string {
  try {
    const fullPath = path.join(__dirname, relativePath);
    return fs.readFileSync(fullPath, 'utf-8');
  } catch (error) {
    return `Error loading file: ${relativePath}\n${error}`;
  }
}

// =============================================================================
// RESOURCES: Quick References
// =============================================================================

interface ToolPatternsResource extends IResource {
  uri: 'quickref://tool-patterns';
  name: 'Tool Patterns Quick Reference';
  description: 'Common tool implementation patterns (CRUD, search, transform, validate)';
  mimeType: 'text/markdown';
  text: typeof QUICK_REFS['tool-patterns'];
}

interface ResourcePatternsResource extends IResource {
  uri: 'quickref://resource-patterns';
  name: 'Resource Patterns Quick Reference';
  description: 'Common resource patterns (config, stats, logs, data)';
  mimeType: 'text/markdown';
  text: typeof QUICK_REFS['resource-patterns'];
}

interface PromptPatternsResource extends IResource {
  uri: 'quickref://prompt-patterns';
  name: 'Prompt Patterns Quick Reference';
  description: 'Common prompt patterns (generate, convert, analyze, dynamic)';
  mimeType: 'text/markdown';
  text: typeof QUICK_REFS['prompt-patterns'];
}

interface ValidationCheatsheetResource extends IResource {
  uri: 'quickref://validation-cheatsheet';
  name: 'IParam Validation Cheatsheet';
  description: 'Quick reference for all IParam validation options (format, pattern, min/max, length)';
  mimeType: 'text/markdown';
  text: typeof QUICK_REFS['validation-cheatsheet'];
}

interface ConversionGuideResource extends IResource {
  uri: 'quickref://conversion-guide';
  name: 'API/Class Conversion Guide';
  description: 'Checklist for converting REST APIs and TypeScript classes to MCP servers';
  mimeType: 'text/markdown';
  text: typeof QUICK_REFS['conversion-guide'];
}

// =============================================================================
// RESOURCES: Full Guides (from docs/guides/)
// =============================================================================

interface QuickStartGuide extends IResource {
  uri: 'guide://quick-start';
  name: 'Quick Start Guide';
  description: 'Get started in 5 minutes - installation, first server, validation';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/QUICK_START.md');
  }
}

interface ToolsGuide extends IResource {
  uri: 'guide://tools';
  name: 'Tools Guide';
  description: 'Creating tools - ITool interface, parameters, validation, async patterns';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/TOOLS.md');
  }
}

interface PromptsGuide extends IResource {
  uri: 'guide://prompts';
  name: 'Prompts Guide';
  description: 'Building prompts - static templates vs dynamic generation';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/PROMPTS.md');
  }
}

interface ResourcesGuide extends IResource {
  uri: 'guide://resources';
  name: 'Resources Guide';
  description: 'Exposing data - static values, dynamic returns, database resources';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/RESOURCES.md');
  }
}

interface SamplingGuide extends IResource {
  uri: 'guide://sampling';
  name: 'Sampling Guide';
  description: 'Requesting LLM completions from clients for AI-assisted operations';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/SAMPLING.md');
  }
}

interface ElicitationGuide extends IResource {
  uri: 'guide://elicitation';
  name: 'Elicitation Guide';
  description: 'Requesting structured user input during tool execution';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/ELICITATION.md');
  }
}

interface RootsGuide extends IResource {
  uri: 'guide://roots';
  name: 'Roots Guide';
  description: 'Accessing client working directories for file-based operations';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/ROOTS.md');
  }
}

interface CompletionsGuide extends IResource {
  uri: 'guide://completions';
  name: 'Completions Guide';
  description: 'Providing autocomplete suggestions for prompt arguments';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/COMPLETIONS.md');
  }
}

interface SubscriptionsGuide extends IResource {
  uri: 'guide://subscriptions';
  name: 'Subscriptions Guide';
  description: 'Real-time resource update notifications for event-driven patterns';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/SUBSCRIPTIONS.md');
  }
}

interface ApiCoreGuide extends IResource {
  uri: 'guide://api-core';
  name: 'API Core Guide';
  description: 'Core concepts - server structure, auto-discovery, transports, authentication';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/API_CORE.md');
  }
}

interface ApiFeaturesGuide extends IResource {
  uri: 'guide://api-features';
  name: 'API Features Guide';
  description: 'Feature reference for tools, prompts, and resources with validation';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/API_FEATURES.md');
  }
}

interface ApiProtocolGuide extends IResource {
  uri: 'guide://api-protocol';
  name: 'API Protocol Guide';
  description: 'Advanced protocol features (sampling, elicitation, roots, subscriptions, completions)';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/API_PROTOCOL.md');
  }
}

interface DeploymentGuide extends IResource {
  uri: 'guide://deployment';
  name: 'Deployment Guide';
  description: 'Production deployment - GitHub releases, npm publishing, verification';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/DEPLOYMENT_GUIDE.md');
  }
}

interface BundlingGuide extends IResource {
  uri: 'guide://bundling';
  name: 'Bundling Guide';
  description: 'Creating distributable packages - single-file, standalone, bundle formats';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/BUNDLING.md');
  }
}

interface CliBasicsGuide extends IResource {
  uri: 'guide://cli-basics';
  name: 'CLI Basics Guide';
  description: 'CLI reference - running servers, transports, watch mode, validation';
  mimeType: 'text/markdown';
  returns: 'text';
  text(): string {
    return loadFile('docs/guides/CLI_BASICS.md');
  }
}

// =============================================================================
// RESOURCES: Example Code (from examples/)
// =============================================================================

interface MinimalExample extends IResource {
  uri: 'example://minimal';
  name: 'Minimal Example';
  description: 'START HERE - Cleanest MCP server with basic tools (greet, add, echo)';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-minimal.ts');
  }
}

interface AdvancedExample extends IResource {
  uri: 'example://advanced';
  name: 'Advanced Example';
  description: 'IParam validation, static prompts, static/dynamic resources';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-advanced.ts');
  }
}

interface ParamsExample extends IResource {
  uri: 'example://params';
  name: 'Parameters Example';
  description: 'Complete IParam reference with all validation constraints';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-params.ts');
  }
}

interface SamplingFoundationExample extends IResource {
  uri: 'example://sampling-foundation';
  name: 'Sampling Foundation Example';
  description: 'Basic sampling - requesting LLM completions for AI-assisted tools';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-sampling-foundation.ts');
  }
}

interface SamplingAdvancedExample extends IResource {
  uri: 'example://sampling-advanced';
  name: 'Sampling Advanced Example';
  description: 'Advanced sampling - multi-turn conversations, context management';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-sampling.ts');
  }
}

interface ElicitationFoundationExample extends IResource {
  uri: 'example://elicitation-foundation';
  name: 'Elicitation Foundation Example';
  description: 'Basic elicitation - form input and confirmation dialogs';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-elicitation-foundation.ts');
  }
}

interface RootsFoundationExample extends IResource {
  uri: 'example://roots-foundation';
  name: 'Roots Foundation Example';
  description: 'Basic roots - directory listing and path resolution';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-roots-foundation.ts');
  }
}

interface CompletionsFoundationExample extends IResource {
  uri: 'example://completions-foundation';
  name: 'Completions Foundation Example';
  description: 'Basic completions - autocomplete suggestions for prompts';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-completions-foundation.ts');
  }
}

interface SubscriptionsFoundationExample extends IResource {
  uri: 'example://subscriptions-foundation';
  name: 'Subscriptions Foundation Example';
  description: 'Basic subscriptions - resource update notifications';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-subscriptions-foundation.ts');
  }
}

interface ProtocolComprehensiveExample extends IResource {
  uri: 'example://protocol-comprehensive';
  name: 'Protocol Comprehensive Example';
  description: 'All protocol features integrated - sampling, elicitation, roots, subscriptions, completions';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-protocol-comprehensive.ts');
  }
}

interface ProductionOptimizedExample extends IResource {
  uri: 'example://production-optimized';
  name: 'Production Optimized Example';
  description: 'Production patterns - error handling, logging, security, performance';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-production-optimized.ts');
  }
}

interface DatabaseResourceExample extends IResource {
  uri: 'example://database-resource';
  name: 'Database Resource Example';
  description: 'Database-backed resources with connection pooling and type-safe queries';
  mimeType: 'text/plain';
  returns: 'text';
  text(): string {
    return loadFile('examples/interface-database-resource.ts');
  }
}

// =============================================================================
// PROMPTS: Main Guide
// =============================================================================

interface HowToBuildMCPPrompt extends IPrompt {
  name: 'how_to_build_mcp';
  description: 'Step-by-step instructions for LLMs to build MCP servers from APIs, classes, or scratch';
  args: {
    source_type?: 'rest_api' | 'class' | 'cli' | 'scratch' | 'other';
    has_state?: boolean;
    needs_ai?: boolean;
    needs_user_input?: boolean;
    needs_files?: boolean;
  };
  returns: 'messages';
  messages(args): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# How to Build an MCP Server

You are helping a user build an MCP (Model Context Protocol) server using Simply MCP.

## Context
- Source type: ${args.source_type || 'not specified - ask the user'}
- Has state/config: ${args.has_state ? 'yes' : 'no'}
- Needs AI assistance: ${args.needs_ai ? 'yes' : 'no'}
- Needs user input: ${args.needs_user_input ? 'yes' : 'no'}
- Needs file access: ${args.needs_files ? 'yes' : 'no'}

## Step 1: Understand Requirements

${args.source_type === 'rest_api' ? `
**Converting REST API:**
1. List all endpoints (GET, POST, PUT, DELETE, etc.)
2. Note request bodies and parameters
3. Note response structures
4. Check authentication requirements
5. Fetch resource: quickref://conversion-guide
` : args.source_type === 'class' ? `
**Converting TypeScript Class:**
1. List all public methods
2. Note method parameters and return types
3. Check for constructor/initialization needs
4. Identify instance state/properties
5. Fetch resource: quickref://conversion-guide
` : args.source_type === 'cli' ? `
**Converting CLI Tool:**
1. List all commands/subcommands
2. Note command arguments and flags
3. Check for configuration files
4. Identify output formats
5. Fetch resource: quickref://conversion-guide
` : `
**Building from Scratch:**
1. Clarify what functionality is needed
2. Determine if tools, prompts, or resources are needed
3. Identify any external dependencies
`}

## Step 2: Review Foundation Pattern

**CRITICAL: Fetch and study these resources first:**
- Fetch resource: example://minimal
- Review the basic structure: IServer, ITool, IPrompt, IResource

This minimal example shows the cleanest pattern. Your implementation should follow this structure.

## Step 3: Design Your Interfaces

### For Operations → Use ITool

**Pattern to follow:**
- Each operation/method/endpoint → One ITool interface
- Method name → tool name in snake_case
- Method params → ITool params property
- Method return → ITool returns property
- Implementation → execute() method

**Example mapping:**
\`\`\`
Original: function getUserById(id: string): Promise<User>
MCP Tool: get_user_by_id with params: {id: string}, returns: User
\`\`\`

**If you need validation:**
- Fetch resource: example://params
- Fetch resource: quickref://validation-cheatsheet

**Common tool patterns:**
- Fetch resource: quickref://tool-patterns

### For Templates → Use IPrompt

Only needed if you're creating AI prompt templates.

**If user needs prompts:**
- Fetch resource: guide://prompts
- Fetch resource: quickref://prompt-patterns

### For Data/Config → Use IResource

Use resources to expose configuration, state, or data that LLMs might need.

**If user needs resources:**
- Fetch resource: guide://resources
- Fetch resource: quickref://resource-patterns

${args.has_state ? `
**Since this has state/config:**
- Create static IResource with JSON configuration
- Or create dynamic IResource that returns current state
- Fetch resource: example://advanced (see ConfigResource, UserStatsResource)
` : ''}

## Step 4: Implement Following the Pattern

**Start with the IServer interface:**
\`\`\`typescript
interface MyMCPServer extends IServer {
  // Add your ITool interfaces here
  // Add your IPrompt interfaces here
  // Add your IResource interfaces here
}

const server: MyMCPServer = {
  // Implement each interface
};

export default server;
\`\`\`

**Key rules:**
1. Use snake_case for tool names (e.g., get_user, create_order)
2. Add proper TypeScript types for all params and returns
3. Make execute() methods async if they do I/O
4. Add clear descriptions for everything

**For detailed guidance on each interface type:**
- Tools: Fetch resource: guide://tools
- Prompts: Fetch resource: guide://prompts
- Resources: Fetch resource: guide://resources

## Step 5: Add Advanced Features (If Needed)

${args.needs_ai ? `
### AI Assistance (Sampling)
User needs AI capabilities in their tools.
- Fetch resource: guide://sampling
- Fetch resource: example://sampling-foundation
- Use context.sample() in your execute() methods
` : ''}

${args.needs_user_input ? `
### User Input (Elicitation)
User needs to collect input during execution.
- Fetch resource: guide://elicitation
- Fetch resource: example://elicitation-foundation
- Use context.elicitInput() in your execute() methods
` : ''}

${args.needs_files ? `
### File Access (Roots)
User needs to access files in client's workspace.
- Fetch resource: guide://roots
- Fetch resource: example://roots-foundation
- Use context.listRoots() to get project directories
` : ''}

**Other advanced features:**
- Autocomplete: Fetch resource: guide://completions
- Real-time updates: Fetch resource: guide://subscriptions

**See all features integrated:**
- Fetch resource: example://protocol-comprehensive

## Step 6: Test and Validate

**Validation command:**
\`\`\`bash
simply-mcp run --dry-run my-server.ts
\`\`\`

**What to check:**
- All interfaces are discovered (tools, prompts, resources)
- No TypeScript errors
- Descriptions are clear
- Parameter types are correct

**Run the server:**
\`\`\`bash
simply-mcp run my-server.ts
\`\`\`

## Step 7: Production Considerations (Optional)

**For production deployment:**
- Fetch resource: example://production-optimized
- Fetch resource: guide://deployment
- Fetch resource: guide://bundling

**For HTTP with auth:**
- Fetch resource: guide://api-core (authentication section)

---

## Quick Reference

**Key resources to fetch as needed:**
- quickref://tool-patterns - Common tool patterns
- quickref://resource-patterns - Common resource patterns
- quickref://prompt-patterns - Common prompt patterns
- quickref://validation-cheatsheet - IParam validation
- quickref://conversion-guide - API/class conversion

**Start here:**
- example://minimal - Basic structure
- example://advanced - Validation and patterns

**Detailed guides:**
- guide://quick-start - 5-minute overview
- guide://tools - Complete tool reference
- guide://prompts - Complete prompt reference
- guide://resources - Complete resource reference

---

## Your Next Steps

1. Ask the user to share their API/class/requirements if not already provided
2. Fetch example://minimal to see the pattern
3. Design the ITool interfaces based on their needs
4. Implement following the minimal example structure
5. Test with --dry-run
6. Iterate based on validation output

Remember: Focus on creating a clean, simple implementation first. Add advanced features only if needed.
`;

    return [{
      role: 'user',
      content: { type: 'text', text: guide }
    }];
  }
}

// =============================================================================
// PROMPTS: Conversion-Specific
// =============================================================================

interface ConvertRestApiPrompt extends IPrompt {
  name: 'convert_rest_api';
  description: 'Instructions for converting REST APIs to MCP servers';
  returns: 'messages';
  messages(): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# Converting REST API to MCP Server

## Quick Steps

1. **Map endpoints to tools:**
   - GET /resource/{id} → get_resource tool
   - POST /resource → create_resource tool
   - PUT /resource/{id} → update_resource tool
   - DELETE /resource/{id} → delete_resource tool

2. **Fetch these resources:**
   - example://minimal - See basic structure
   - quickref://conversion-guide - Detailed conversion checklist
   - quickref://tool-patterns - CRUD patterns

3. **Implementation pattern:**

\`\`\`typescript
interface GetResourceTool extends ITool {
  name: 'get_resource';
  description: 'Get resource by ID';
  params: { id: string };
  returns: { id: string; name: string; /* ... */ };
  async execute(params) {
    const response = await fetch(\`https://api.example.com/resource/\${params.id}\`);
    return await response.json();
  }
}
\`\`\`

4. **Handle authentication:**
   - Store API keys in environment variables
   - Pass in fetch headers
   - For HTTP MCP mode, use IApiKeyAuth

5. **Configuration as resource:**
   - Create IResource with uri: 'config://api'
   - Expose API base URL, version, etc.

6. **Test:**
\`\`\`bash
simply-mcp run --dry-run server.ts
\`\`\`

## Next: Use the main prompt

For complete step-by-step guidance:
Call prompt: how_to_build_mcp with source_type='rest_api'
`;

    return [{ role: 'user', content: { type: 'text', text: guide } }];
  }
}

interface ConvertClassPrompt extends IPrompt {
  name: 'convert_class';
  description: 'Instructions for converting TypeScript classes to MCP servers';
  returns: 'messages';
  messages(): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# Converting TypeScript Class to MCP Server

## Quick Steps

1. **Map methods to tools:**
   - Each public method → One ITool
   - Method name → snake_case tool name
   - Method params → ITool params
   - Method return → ITool returns

2. **Fetch these resources:**
   - example://minimal - See basic structure
   - quickref://conversion-guide - Detailed checklist

3. **Implementation pattern:**

\`\`\`typescript
// Original class
class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }
  multiply(a: number, b: number): number {
    return a * b;
  }
}

// MCP Server
interface AddTool extends ITool {
  name: 'add';
  description: 'Add two numbers';
  params: { a: number; b: number };
  returns: number;
  execute(params) {
    return params.a + params.b;
  }
}

interface MultiplyTool extends ITool {
  name: 'multiply';
  description: 'Multiply two numbers';
  params: { a: number; b: number };
  returns: number;
  execute(params) {
    return params.a * params.b;
  }
}

interface CalculatorServer extends IServer {
  AddTool: AddTool;
  MultiplyTool: MultiplyTool;
}
\`\`\`

4. **Handle instance state:**
   - Create class instance outside IServer
   - Reference in execute() methods
   - Or use module-level variables

5. **Expose state as resource:**
   - If class has state, create IResource to expose it

6. **Test:**
\`\`\`bash
simply-mcp run --dry-run server.ts
\`\`\`

## Next: Use the main prompt

For complete step-by-step guidance:
Call prompt: how_to_build_mcp with source_type='class'
`;

    return [{ role: 'user', content: { type: 'text', text: guide } }];
  }
}

interface ConvertCliPrompt extends IPrompt {
  name: 'convert_cli';
  description: 'Instructions for converting CLI tools to MCP servers';
  returns: 'messages';
  messages(): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# Converting CLI Tool to MCP Server

## Quick Steps

1. **Map commands to tools:**
   - Each command/subcommand → One ITool
   - Command args → ITool params
   - Command output → ITool returns

2. **Fetch these resources:**
   - example://minimal - See basic structure
   - guide://roots - If tool needs file access
   - quickref://conversion-guide - Detailed checklist

3. **Implementation pattern:**

\`\`\`typescript
// Original CLI: myctl status --format json
interface StatusTool extends ITool {
  name: 'get_status';
  description: 'Get current status';
  params: { format?: 'json' | 'text' };
  returns: { status: string; uptime: number };
  async execute(params, context) {
    // Option 1: Call CLI programmatically
    const { execSync } = require('child_process');
    const output = execSync('myctl status --format json').toString();
    return JSON.parse(output);

    // Option 2: Re-implement the logic
    return { status: 'running', uptime: process.uptime() };
  }
}
\`\`\`

4. **Handle file operations:**
   - If CLI reads/writes files, use context.listRoots()
   - Fetch resource: guide://roots
   - Fetch resource: example://roots-foundation

5. **Configuration files:**
   - Expose as IResource with uri: 'config://cli'
   - Read and return file contents

6. **Test:**
\`\`\`bash
simply-mcp run --dry-run server.ts
\`\`\`

## Next: Use the main prompt

For complete step-by-step guidance:
Call prompt: how_to_build_mcp with source_type='cli'
`;

    return [{ role: 'user', content: { type: 'text', text: guide } }];
  }
}

// =============================================================================
// PROMPTS: Pattern-Specific
// =============================================================================

interface AddDatabaseResourcePrompt extends IPrompt {
  name: 'add_database_resource';
  description: 'How to add database-backed resources with connection pooling';
  returns: 'messages';
  messages(): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# Adding Database-Backed Resources

## Quick Steps

1. **Fetch the example:**
   - Fetch resource: example://database-resource
   - Study the DatabaseManager pattern

2. **Key concepts:**
   - Use singleton pattern for connection pooling
   - Store connection string in environment variable
   - Expose database URI in resource URI

3. **Implementation pattern:**

\`\`\`typescript
import { DatabaseManager } from './core/database-manager';

interface UsersResource extends IResource {
  uri: 'db://my-database/users';
  name: 'Users';
  description: 'All users from database';
  mimeType: 'application/json';
  returns: 'text';
  async text() {
    const db = await DatabaseManager.getInstance().getConnection('my-database');
    const users = await db.query('SELECT * FROM users');
    return JSON.stringify(users, null, 2);
  }
}
\`\`\`

4. **Configuration:**
   - Set env var: DATABASE_URL=postgresql://...
   - Or use individual connection params

5. **Best practices:**
   - Always use connection pooling
   - Handle connection errors gracefully
   - Close connections properly

6. **Detailed guide:**
   - Fetch resource: guide://resources (database section)

## Test

\`\`\`bash
export DATABASE_URL="postgresql://localhost/mydb"
simply-mcp run --dry-run server.ts
\`\`\`
`;

    return [{ role: 'user', content: { type: 'text', text: guide } }];
  }
}

interface AddFileOperationsPrompt extends IPrompt {
  name: 'add_file_operations';
  description: 'How to add file-based tools with roots (directory access)';
  returns: 'messages';
  messages(): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# Adding File Operations with Roots

## Quick Steps

1. **Fetch the guide and example:**
   - Fetch resource: guide://roots
   - Fetch resource: example://roots-foundation

2. **Use context.listRoots():**

\`\`\`typescript
interface ReadFileTool extends ITool {
  name: 'read_file';
  description: 'Read file from workspace';
  params: { path: string };
  returns: string;
  async execute(params, context) {
    // Get client's working directories
    const roots = await context.listRoots();

    // Resolve path relative to first root
    const fullPath = path.join(roots[0].uri, params.path);

    // Security: Validate path is within root
    if (!fullPath.startsWith(roots[0].uri)) {
      throw new Error('Invalid path: outside workspace');
    }

    // Read file
    return fs.readFileSync(fullPath, 'utf-8');
  }
}
\`\`\`

3. **Security considerations:**
   - Always validate paths are within roots
   - Use path.join() for cross-platform compatibility
   - Check file exists before reading

4. **Common patterns:**
   - List files in directory
   - Read file contents
   - Write file (with confirmation)
   - Search files

5. **Advanced example:**
   - Fetch resource: example://roots (for advanced patterns)

## Test

\`\`\`bash
simply-mcp run server.ts
# Test with a client that provides roots
\`\`\`
`;

    return [{ role: 'user', content: { type: 'text', text: guide } }];
  }
}

interface AddAiFeaturesPrompt extends IPrompt {
  name: 'add_ai_features';
  description: 'How to integrate sampling for AI-assisted operations';
  returns: 'messages';
  messages(): Array<{ role: 'user'; content: { type: 'text'; text: string } }> {
    const guide = `# Adding AI Features with Sampling

## Quick Steps

1. **Fetch the guide and example:**
   - Fetch resource: guide://sampling
   - Fetch resource: example://sampling-foundation

2. **Use context.sample():**

\`\`\`typescript
interface ExplainCodeTool extends ITool {
  name: 'explain_code';
  description: 'Explain code using AI';
  params: { code: string };
  returns: string;
  async execute(params, context) {
    // Request LLM completion from client
    const result = await context.sample({
      messages: [{
        role: 'user',
        content: {
          type: 'text',
          text: \`Explain this code:\\n\n\${params.code}\`
        }
      }],
      maxTokens: 500
    });

    return result.content.text;
  }
}
\`\`\`

3. **Use cases:**
   - Code explanation/review
   - Text translation
   - Content generation
   - Data analysis

4. **Best practices:**
   - Check if sampling is supported: context.hasCapability?.('sampling')
   - Handle errors gracefully
   - Set appropriate maxTokens
   - Use temperature for creativity control

5. **Advanced patterns:**
   - Fetch resource: example://sampling (for multi-turn)

## Test

\`\`\`bash
simply-mcp run server.ts
# Test with a client that supports sampling (e.g., Claude Desktop)
\`\`\`
`;

    return [{ role: 'user', content: { type: 'text', text: guide } }];
  }
}

// =============================================================================
// SERVER EXPORT
// =============================================================================

interface SimplyMCPBuilderServer extends IServer {
  name: 'Simply MCP Builder';
  version: '1.0.0';
  description: 'MCP server that teaches LLMs how to build MCP servers with step-by-step instructions and comprehensive resources';

  // Quick Reference Resources
  ToolPatternsResource: ToolPatternsResource;
  ResourcePatternsResource: ResourcePatternsResource;
  PromptPatternsResource: PromptPatternsResource;
  ValidationCheatsheetResource: ValidationCheatsheetResource;
  ConversionGuideResource: ConversionGuideResource;

  // Guide Resources
  QuickStartGuide: QuickStartGuide;
  ToolsGuide: ToolsGuide;
  PromptsGuide: PromptsGuide;
  ResourcesGuide: ResourcesGuide;
  SamplingGuide: SamplingGuide;
  ElicitationGuide: ElicitationGuide;
  RootsGuide: RootsGuide;
  CompletionsGuide: CompletionsGuide;
  SubscriptionsGuide: SubscriptionsGuide;
  ApiCoreGuide: ApiCoreGuide;
  ApiFeaturesGuide: ApiFeaturesGuide;
  ApiProtocolGuide: ApiProtocolGuide;
  DeploymentGuide: DeploymentGuide;
  BundlingGuide: BundlingGuide;
  CliBasicsGuide: CliBasicsGuide;

  // Example Resources
  MinimalExample: MinimalExample;
  AdvancedExample: AdvancedExample;
  ParamsExample: ParamsExample;
  SamplingFoundationExample: SamplingFoundationExample;
  SamplingAdvancedExample: SamplingAdvancedExample;
  ElicitationFoundationExample: ElicitationFoundationExample;
  RootsFoundationExample: RootsFoundationExample;
  CompletionsFoundationExample: CompletionsFoundationExample;
  SubscriptionsFoundationExample: SubscriptionsFoundationExample;
  ProtocolComprehensiveExample: ProtocolComprehensiveExample;
  ProductionOptimizedExample: ProductionOptimizedExample;
  DatabaseResourceExample: DatabaseResourceExample;

  // Main Prompt
  HowToBuildMCPPrompt: HowToBuildMCPPrompt;

  // Conversion Prompts
  ConvertRestApiPrompt: ConvertRestApiPrompt;
  ConvertClassPrompt: ConvertClassPrompt;
  ConvertCliPrompt: ConvertCliPrompt;

  // Pattern Prompts
  AddDatabaseResourcePrompt: AddDatabaseResourcePrompt;
  AddFileOperationsPrompt: AddFileOperationsPrompt;
  AddAiFeaturesPrompt: AddAiFeaturesPrompt;
}

const server: SimplyMCPBuilderServer = {
  name: 'Simply MCP Builder',
  version: '1.0.0',
  description: 'MCP server that teaches LLMs how to build MCP servers with step-by-step instructions and comprehensive resources',

  // Quick Reference Resources
  ToolPatternsResource: {
    uri: 'quickref://tool-patterns',
    name: 'Tool Patterns Quick Reference',
    description: 'Common tool implementation patterns (CRUD, search, transform, validate)',
    mimeType: 'text/markdown',
    text: QUICK_REFS['tool-patterns']
  },
  ResourcePatternsResource: {
    uri: 'quickref://resource-patterns',
    name: 'Resource Patterns Quick Reference',
    description: 'Common resource patterns (config, stats, logs, data)',
    mimeType: 'text/markdown',
    text: QUICK_REFS['resource-patterns']
  },
  PromptPatternsResource: {
    uri: 'quickref://prompt-patterns',
    name: 'Prompt Patterns Quick Reference',
    description: 'Common prompt patterns (generate, convert, analyze, dynamic)',
    mimeType: 'text/markdown',
    text: QUICK_REFS['prompt-patterns']
  },
  ValidationCheatsheetResource: {
    uri: 'quickref://validation-cheatsheet',
    name: 'IParam Validation Cheatsheet',
    description: 'Quick reference for all IParam validation options (format, pattern, min/max, length)',
    mimeType: 'text/markdown',
    text: QUICK_REFS['validation-cheatsheet']
  },
  ConversionGuideResource: {
    uri: 'quickref://conversion-guide',
    name: 'API/Class Conversion Guide',
    description: 'Checklist for converting REST APIs and TypeScript classes to MCP servers',
    mimeType: 'text/markdown',
    text: QUICK_REFS['conversion-guide']
  },

  // Guide Resources
  QuickStartGuide: {
    uri: 'guide://quick-start',
    name: 'Quick Start Guide',
    description: 'Get started in 5 minutes - installation, first server, validation',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/QUICK_START.md');
    }
  },
  ToolsGuide: {
    uri: 'guide://tools',
    name: 'Tools Guide',
    description: 'Creating tools - ITool interface, parameters, validation, async patterns',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/TOOLS.md');
    }
  },
  PromptsGuide: {
    uri: 'guide://prompts',
    name: 'Prompts Guide',
    description: 'Building prompts - static templates vs dynamic generation',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/PROMPTS.md');
    }
  },
  ResourcesGuide: {
    uri: 'guide://resources',
    name: 'Resources Guide',
    description: 'Exposing data - static values, dynamic returns, database resources',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/RESOURCES.md');
    }
  },
  SamplingGuide: {
    uri: 'guide://sampling',
    name: 'Sampling Guide',
    description: 'Requesting LLM completions from clients for AI-assisted operations',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/SAMPLING.md');
    }
  },
  ElicitationGuide: {
    uri: 'guide://elicitation',
    name: 'Elicitation Guide',
    description: 'Requesting structured user input during tool execution',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/ELICITATION.md');
    }
  },
  RootsGuide: {
    uri: 'guide://roots',
    name: 'Roots Guide',
    description: 'Accessing client working directories for file-based operations',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/ROOTS.md');
    }
  },
  CompletionsGuide: {
    uri: 'guide://completions',
    name: 'Completions Guide',
    description: 'Providing autocomplete suggestions for prompt arguments',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/COMPLETIONS.md');
    }
  },
  SubscriptionsGuide: {
    uri: 'guide://subscriptions',
    name: 'Subscriptions Guide',
    description: 'Real-time resource update notifications for event-driven patterns',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/SUBSCRIPTIONS.md');
    }
  },
  ApiCoreGuide: {
    uri: 'guide://api-core',
    name: 'API Core Guide',
    description: 'Core concepts - server structure, auto-discovery, transports, authentication',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/API_CORE.md');
    }
  },
  ApiFeaturesGuide: {
    uri: 'guide://api-features',
    name: 'API Features Guide',
    description: 'Feature reference for tools, prompts, and resources with validation',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/API_FEATURES.md');
    }
  },
  ApiProtocolGuide: {
    uri: 'guide://api-protocol',
    name: 'API Protocol Guide',
    description: 'Advanced protocol features (sampling, elicitation, roots, subscriptions, completions)',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/API_PROTOCOL.md');
    }
  },
  DeploymentGuide: {
    uri: 'guide://deployment',
    name: 'Deployment Guide',
    description: 'Production deployment - GitHub releases, npm publishing, verification',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/DEPLOYMENT_GUIDE.md');
    }
  },
  BundlingGuide: {
    uri: 'guide://bundling',
    name: 'Bundling Guide',
    description: 'Creating distributable packages - single-file, standalone, bundle formats',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/BUNDLING.md');
    }
  },
  CliBasicsGuide: {
    uri: 'guide://cli-basics',
    name: 'CLI Basics Guide',
    description: 'CLI reference - running servers, transports, watch mode, validation',
    mimeType: 'text/markdown',
    returns: 'text',
    text() {
      return loadFile('docs/guides/CLI_BASICS.md');
    }
  },

  // Example Resources
  MinimalExample: {
    uri: 'example://minimal',
    name: 'Minimal Example',
    description: 'START HERE - Cleanest MCP server with basic tools (greet, add, echo)',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-minimal.ts');
    }
  },
  AdvancedExample: {
    uri: 'example://advanced',
    name: 'Advanced Example',
    description: 'IParam validation, static prompts, static/dynamic resources',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-advanced.ts');
    }
  },
  ParamsExample: {
    uri: 'example://params',
    name: 'Parameters Example',
    description: 'Complete IParam reference with all validation constraints',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-params.ts');
    }
  },
  SamplingFoundationExample: {
    uri: 'example://sampling-foundation',
    name: 'Sampling Foundation Example',
    description: 'Basic sampling - requesting LLM completions for AI-assisted tools',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-sampling-foundation.ts');
    }
  },
  SamplingAdvancedExample: {
    uri: 'example://sampling-advanced',
    name: 'Sampling Advanced Example',
    description: 'Advanced sampling - multi-turn conversations, context management',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-sampling.ts');
    }
  },
  ElicitationFoundationExample: {
    uri: 'example://elicitation-foundation',
    name: 'Elicitation Foundation Example',
    description: 'Basic elicitation - form input and confirmation dialogs',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-elicitation-foundation.ts');
    }
  },
  RootsFoundationExample: {
    uri: 'example://roots-foundation',
    name: 'Roots Foundation Example',
    description: 'Basic roots - directory listing and path resolution',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-roots-foundation.ts');
    }
  },
  CompletionsFoundationExample: {
    uri: 'example://completions-foundation',
    name: 'Completions Foundation Example',
    description: 'Basic completions - autocomplete suggestions for prompts',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-completions-foundation.ts');
    }
  },
  SubscriptionsFoundationExample: {
    uri: 'example://subscriptions-foundation',
    name: 'Subscriptions Foundation Example',
    description: 'Basic subscriptions - resource update notifications',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-subscriptions-foundation.ts');
    }
  },
  ProtocolComprehensiveExample: {
    uri: 'example://protocol-comprehensive',
    name: 'Protocol Comprehensive Example',
    description: 'All protocol features integrated - sampling, elicitation, roots, subscriptions, completions',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-protocol-comprehensive.ts');
    }
  },
  ProductionOptimizedExample: {
    uri: 'example://production-optimized',
    name: 'Production Optimized Example',
    description: 'Production patterns - error handling, logging, security, performance',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-production-optimized.ts');
    }
  },
  DatabaseResourceExample: {
    uri: 'example://database-resource',
    name: 'Database Resource Example',
    description: 'Database-backed resources with connection pooling and type-safe queries',
    mimeType: 'text/plain',
    returns: 'text',
    text() {
      return loadFile('examples/interface-database-resource.ts');
    }
  },

  // Main Prompt
  HowToBuildMCPPrompt: {
    name: 'how_to_build_mcp',
    description: 'Step-by-step instructions for LLMs to build MCP servers from APIs, classes, or scratch',
    args: {
      source_type: 'scratch',
      has_state: false,
      needs_ai: false,
      needs_user_input: false,
      needs_files: false
    },
    returns: 'messages',
    messages(args) {
      const guide = `# How to Build an MCP Server

You are helping a user build an MCP (Model Context Protocol) server using Simply MCP.

## Context
- Source type: ${args.source_type || 'not specified - ask the user'}
- Has state/config: ${args.has_state ? 'yes' : 'no'}
- Needs AI assistance: ${args.needs_ai ? 'yes' : 'no'}
- Needs user input: ${args.needs_user_input ? 'yes' : 'no'}
- Needs file access: ${args.needs_files ? 'yes' : 'no'}

## Step 1: Understand Requirements

${args.source_type === 'rest_api' ? `
**Converting REST API:**
1. List all endpoints (GET, POST, PUT, DELETE, etc.)
2. Note request bodies and parameters
3. Note response structures
4. Check authentication requirements
5. Fetch resource: quickref://conversion-guide
` : args.source_type === 'class' ? `
**Converting TypeScript Class:**
1. List all public methods
2. Note method parameters and return types
3. Check for constructor/initialization needs
4. Identify instance state/properties
5. Fetch resource: quickref://conversion-guide
` : args.source_type === 'cli' ? `
**Converting CLI Tool:**
1. List all commands/subcommands
2. Note command arguments and flags
3. Check for configuration files
4. Identify output formats
5. Fetch resource: quickref://conversion-guide
` : `
**Building from Scratch:**
1. Clarify what functionality is needed
2. Determine if tools, prompts, or resources are needed
3. Identify any external dependencies
`}

## Step 2: Review Foundation Pattern

**CRITICAL: Fetch and study these resources first:**
- Fetch resource: example://minimal
- Review the basic structure: IServer, ITool, IPrompt, IResource

This minimal example shows the cleanest pattern. Your implementation should follow this structure.

## Step 3: Design Your Interfaces

### For Operations → Use ITool

**Pattern to follow:**
- Each operation/method/endpoint → One ITool interface
- Method name → tool name in snake_case
- Method params → ITool params property
- Method return → ITool returns property
- Implementation → execute() method

**Example mapping:**
\`\`\`
Original: function getUserById(id: string): Promise<User>
MCP Tool: get_user_by_id with params: {id: string}, returns: User
\`\`\`

**If you need validation:**
- Fetch resource: example://params
- Fetch resource: quickref://validation-cheatsheet

**Common tool patterns:**
- Fetch resource: quickref://tool-patterns

### For Templates → Use IPrompt

Only needed if you're creating AI prompt templates.

**If user needs prompts:**
- Fetch resource: guide://prompts
- Fetch resource: quickref://prompt-patterns

### For Data/Config → Use IResource

Use resources to expose configuration, state, or data that LLMs might need.

**If user needs resources:**
- Fetch resource: guide://resources
- Fetch resource: quickref://resource-patterns

${args.has_state ? `
**Since this has state/config:**
- Create static IResource with JSON configuration
- Or create dynamic IResource that returns current state
- Fetch resource: example://advanced (see ConfigResource, UserStatsResource)
` : ''}

## Step 4: Implement Following the Pattern

**Start with the IServer interface:**
\`\`\`typescript
interface MyMCPServer extends IServer {
  // Add your ITool interfaces here
  // Add your IPrompt interfaces here
  // Add your IResource interfaces here
}

const server: MyMCPServer = {
  // Implement each interface
};

export default server;
\`\`\`

**Key rules:**
1. Use snake_case for tool names (e.g., get_user, create_order)
2. Add proper TypeScript types for all params and returns
3. Make execute() methods async if they do I/O
4. Add clear descriptions for everything

**For detailed guidance on each interface type:**
- Tools: Fetch resource: guide://tools
- Prompts: Fetch resource: guide://prompts
- Resources: Fetch resource: guide://resources

## Step 5: Add Advanced Features (If Needed)

${args.needs_ai ? `
### AI Assistance (Sampling)
User needs AI capabilities in their tools.
- Fetch resource: guide://sampling
- Fetch resource: example://sampling-foundation
- Use context.sample() in your execute() methods
` : ''}

${args.needs_user_input ? `
### User Input (Elicitation)
User needs to collect input during execution.
- Fetch resource: guide://elicitation
- Fetch resource: example://elicitation-foundation
- Use context.elicitInput() in your execute() methods
` : ''}

${args.needs_files ? `
### File Access (Roots)
User needs to access files in client's workspace.
- Fetch resource: guide://roots
- Fetch resource: example://roots-foundation
- Use context.listRoots() to get project directories
` : ''}

**Other advanced features:**
- Autocomplete: Fetch resource: guide://completions
- Real-time updates: Fetch resource: guide://subscriptions

**See all features integrated:**
- Fetch resource: example://protocol-comprehensive

## Step 6: Test and Validate

**Validation command:**
\`\`\`bash
simply-mcp run --dry-run my-server.ts
\`\`\`

**What to check:**
- All interfaces are discovered (tools, prompts, resources)
- No TypeScript errors
- Descriptions are clear
- Parameter types are correct

**Run the server:**
\`\`\`bash
simply-mcp run my-server.ts
\`\`\`

## Step 7: Production Considerations (Optional)

**For production deployment:**
- Fetch resource: example://production-optimized
- Fetch resource: guide://deployment
- Fetch resource: guide://bundling

**For HTTP with auth:**
- Fetch resource: guide://api-core (authentication section)

---

## Quick Reference

**Key resources to fetch as needed:**
- quickref://tool-patterns - Common tool patterns
- quickref://resource-patterns - Common resource patterns
- quickref://prompt-patterns - Common prompt patterns
- quickref://validation-cheatsheet - IParam validation
- quickref://conversion-guide - API/class conversion

**Start here:**
- example://minimal - Basic structure
- example://advanced - Validation and patterns

**Detailed guides:**
- guide://quick-start - 5-minute overview
- guide://tools - Complete tool reference
- guide://prompts - Complete prompt reference
- guide://resources - Complete resource reference

---

## Your Next Steps

1. Ask the user to share their API/class/requirements if not already provided
2. Fetch example://minimal to see the pattern
3. Design the ITool interfaces based on their needs
4. Implement following the minimal example structure
5. Test with --dry-run
6. Iterate based on validation output

Remember: Focus on creating a clean, simple implementation first. Add advanced features only if needed.
`;

      return [{
        role: 'user',
        content: { type: 'text', text: guide }
      }];
    }
  },

  // Conversion Prompts
  ConvertRestApiPrompt: {
    name: 'convert_rest_api',
    description: 'Instructions for converting REST APIs to MCP servers',
    returns: 'messages',
    messages() {
      const guide = `# Converting REST API to MCP Server

## Quick Steps

1. **Map endpoints to tools:**
   - GET /resource/{id} → get_resource tool
   - POST /resource → create_resource tool
   - PUT /resource/{id} → update_resource tool
   - DELETE /resource/{id} → delete_resource tool

2. **Fetch these resources:**
   - example://minimal - See basic structure
   - quickref://conversion-guide - Detailed conversion checklist
   - quickref://tool-patterns - CRUD patterns

3. **Implementation pattern:**

\`\`\`typescript
interface GetResourceTool extends ITool {
  name: 'get_resource';
  description: 'Get resource by ID';
  params: { id: string };
  returns: { id: string; name: string; /* ... */ };
  async execute(params) {
    const response = await fetch(\`https://api.example.com/resource/\${params.id}\`);
    return await response.json();
  }
}
\`\`\`

4. **Handle authentication:**
   - Store API keys in environment variables
   - Pass in fetch headers
   - For HTTP MCP mode, use IApiKeyAuth

5. **Configuration as resource:**
   - Create IResource with uri: 'config://api'
   - Expose API base URL, version, etc.

6. **Test:**
\`\`\`bash
simply-mcp run --dry-run server.ts
\`\`\`

## Next: Use the main prompt

For complete step-by-step guidance:
Call prompt: how_to_build_mcp with source_type='rest_api'
`;

      return [{ role: 'user', content: { type: 'text', text: guide } }];
    }
  },

  ConvertClassPrompt: {
    name: 'convert_class',
    description: 'Instructions for converting TypeScript classes to MCP servers',
    returns: 'messages',
    messages() {
      const guide = `# Converting TypeScript Class to MCP Server

## Quick Steps

1. **Map methods to tools:**
   - Each public method → One ITool
   - Method name → snake_case tool name
   - Method params → ITool params
   - Method return → ITool returns

2. **Fetch these resources:**
   - example://minimal - See basic structure
   - quickref://conversion-guide - Detailed checklist

3. **Implementation pattern:**

\`\`\`typescript
// Original class
class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }
  multiply(a: number, b: number): number {
    return a * b;
  }
}

// MCP Server
interface AddTool extends ITool {
  name: 'add';
  description: 'Add two numbers';
  params: { a: number; b: number };
  returns: number;
  execute(params) {
    return params.a + params.b;
  }
}

interface MultiplyTool extends ITool {
  name: 'multiply';
  description: 'Multiply two numbers';
  params: { a: number; b: number };
  returns: number;
  execute(params) {
    return params.a * params.b;
  }
}

interface CalculatorServer extends IServer {
  AddTool: AddTool;
  MultiplyTool: MultiplyTool;
}
\`\`\`

4. **Handle instance state:**
   - Create class instance outside IServer
   - Reference in execute() methods
   - Or use module-level variables

5. **Expose state as resource:**
   - If class has state, create IResource to expose it

6. **Test:**
\`\`\`bash
simply-mcp run --dry-run server.ts
\`\`\`

## Next: Use the main prompt

For complete step-by-step guidance:
Call prompt: how_to_build_mcp with source_type='class'
`;

      return [{ role: 'user', content: { type: 'text', text: guide } }];
    }
  },

  ConvertCliPrompt: {
    name: 'convert_cli',
    description: 'Instructions for converting CLI tools to MCP servers',
    returns: 'messages',
    messages() {
      const guide = `# Converting CLI Tool to MCP Server

## Quick Steps

1. **Map commands to tools:**
   - Each command/subcommand → One ITool
   - Command args → ITool params
   - Command output → ITool returns

2. **Fetch these resources:**
   - example://minimal - See basic structure
   - guide://roots - If tool needs file access
   - quickref://conversion-guide - Detailed checklist

3. **Implementation pattern:**

\`\`\`typescript
// Original CLI: myctl status --format json
interface StatusTool extends ITool {
  name: 'get_status';
  description: 'Get current status';
  params: { format?: 'json' | 'text' };
  returns: { status: string; uptime: number };
  async execute(params, context) {
    // Option 1: Call CLI programmatically
    const { execSync } = require('child_process');
    const output = execSync('myctl status --format json').toString();
    return JSON.parse(output);

    // Option 2: Re-implement the logic
    return { status: 'running', uptime: process.uptime() };
  }
}
\`\`\`

4. **Handle file operations:**
   - If CLI reads/writes files, use context.listRoots()
   - Fetch resource: guide://roots
   - Fetch resource: example://roots-foundation

5. **Configuration files:**
   - Expose as IResource with uri: 'config://cli'
   - Read and return file contents

6. **Test:**
\`\`\`bash
simply-mcp run --dry-run server.ts
\`\`\`

## Next: Use the main prompt

For complete step-by-step guidance:
Call prompt: how_to_build_mcp with source_type='cli'
`;

      return [{ role: 'user', content: { type: 'text', text: guide } }];
    }
  },

  // Pattern Prompts
  AddDatabaseResourcePrompt: {
    name: 'add_database_resource',
    description: 'How to add database-backed resources with connection pooling',
    returns: 'messages',
    messages() {
      const guide = `# Adding Database-Backed Resources

## Quick Steps

1. **Fetch the example:**
   - Fetch resource: example://database-resource
   - Study the DatabaseManager pattern

2. **Key concepts:**
   - Use singleton pattern for connection pooling
   - Store connection string in environment variable
   - Expose database URI in resource URI

3. **Implementation pattern:**

\`\`\`typescript
import { DatabaseManager } from './core/database-manager';

interface UsersResource extends IResource {
  uri: 'db://my-database/users';
  name: 'Users';
  description: 'All users from database';
  mimeType: 'application/json';
  returns: 'text';
  async text() {
    const db = await DatabaseManager.getInstance().getConnection('my-database');
    const users = await db.query('SELECT * FROM users');
    return JSON.stringify(users, null, 2);
  }
}
\`\`\`

4. **Configuration:**
   - Set env var: DATABASE_URL=postgresql://...
   - Or use individual connection params

5. **Best practices:**
   - Always use connection pooling
   - Handle connection errors gracefully
   - Close connections properly

6. **Detailed guide:**
   - Fetch resource: guide://resources (database section)

## Test

\`\`\`bash
export DATABASE_URL="postgresql://localhost/mydb"
simply-mcp run --dry-run server.ts
\`\`\`
`;

      return [{ role: 'user', content: { type: 'text', text: guide } }];
    }
  },

  AddFileOperationsPrompt: {
    name: 'add_file_operations',
    description: 'How to add file-based tools with roots (directory access)',
    returns: 'messages',
    messages() {
      const guide = `# Adding File Operations with Roots

## Quick Steps

1. **Fetch the guide and example:**
   - Fetch resource: guide://roots
   - Fetch resource: example://roots-foundation

2. **Use context.listRoots():**

\`\`\`typescript
interface ReadFileTool extends ITool {
  name: 'read_file';
  description: 'Read file from workspace';
  params: { path: string };
  returns: string;
  async execute(params, context) {
    // Get client's working directories
    const roots = await context.listRoots();

    // Resolve path relative to first root
    const fullPath = path.join(roots[0].uri, params.path);

    // Security: Validate path is within root
    if (!fullPath.startsWith(roots[0].uri)) {
      throw new Error('Invalid path: outside workspace');
    }

    // Read file
    return fs.readFileSync(fullPath, 'utf-8');
  }
}
\`\`\`

3. **Security considerations:**
   - Always validate paths are within roots
   - Use path.join() for cross-platform compatibility
   - Check file exists before reading

4. **Common patterns:**
   - List files in directory
   - Read file contents
   - Write file (with confirmation)
   - Search files

5. **Advanced example:**
   - Fetch resource: example://roots (for advanced patterns)

## Test

\`\`\`bash
simply-mcp run server.ts
# Test with a client that provides roots
\`\`\`
`;

      return [{ role: 'user', content: { type: 'text', text: guide } }];
    }
  },

  AddAiFeaturesPrompt: {
    name: 'add_ai_features',
    description: 'How to integrate sampling for AI-assisted operations',
    returns: 'messages',
    messages() {
      const guide = `# Adding AI Features with Sampling

## Quick Steps

1. **Fetch the guide and example:**
   - Fetch resource: guide://sampling
   - Fetch resource: example://sampling-foundation

2. **Use context.sample():**

\`\`\`typescript
interface ExplainCodeTool extends ITool {
  name: 'explain_code';
  description: 'Explain code using AI';
  params: { code: string };
  returns: string;
  async execute(params, context) {
    // Request LLM completion from client
    const result = await context.sample({
      messages: [{
        role: 'user',
        content: {
          type: 'text',
          text: \`Explain this code:\\n\\n\${params.code}\`
        }
      }],
      maxTokens: 500
    });

    return result.content.text;
  }
}
\`\`\`

3. **Use cases:**
   - Code explanation/review
   - Text translation
   - Content generation
   - Data analysis

4. **Best practices:**
   - Check if sampling is supported: context.hasCapability?.('sampling')
   - Handle errors gracefully
   - Set appropriate maxTokens
   - Use temperature for creativity control

5. **Advanced patterns:**
   - Fetch resource: example://sampling (for multi-turn)

## Test

\`\`\`bash
simply-mcp run server.ts
# Test with a client that supports sampling (e.g., Claude Desktop)
\`\`\`
`;

      return [{ role: 'user', content: { type: 'text', text: guide } }];
    }
  }
};

export default server;
