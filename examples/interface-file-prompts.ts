/**
 * Interface API Example: File-Based Prompts
 *
 * Demonstrates how to load prompts from external markdown files
 * using the Interface API. Shows both static and dynamic approaches.
 *
 * Run: npx simply-mcp run examples/interface-file-prompts.ts
 */

import type { ITool, IPrompt, IServer } from '../src/index.js';
import { readFileSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

// Get current directory for file loading
const __dirname = dirname(fileURLToPath(import.meta.url));

// ============================================================================
// Load prompt content from files (at module level)
// ============================================================================

// Example prompt files (using inline strings for demo - in real app, these would be .md files)
const orchestratorPrompt = `# Agentic Coding Loop: Orchestrator Guide

You are an orchestrator responsible for coordinating specialist agents to complete software engineering work.

Your responsibilities:
- Assess task complexity
- Decompose work into subtasks
- Select appropriate agents
- Validate outputs
- Iterate when needed

## Task
{task}

## Context
{context}`;

const adminPrompt = `# Ubuntu System Administrator Guide

You are an expert Linux system administrator specializing in Ubuntu.

Your expertise includes:
- Package management (apt, dpkg)
- Service management (systemd)
- File permissions and ownership
- Network configuration
- Security hardening

## Task
{task}`;

// ============================================================================
// Pattern 1: Static Prompts (Recommended for file-based prompts)
// ============================================================================

interface OrchestratorPromptTool extends IPrompt {
  name: 'orchestrator';
  description: 'Agentic coding loop guide for orchestrating subagents';
  args: {
    task: string;
    context?: string;
  };
  // IMPORTANT: Parser can't detect that orchestratorPrompt is a constant string
  // Must mark as dynamic: true and implement, OR use literal string directly
  dynamic: true;
}

interface AdminPromptTool extends IPrompt {
  name: 'ubuntuAdmin';
  description: 'Expert Linux system administrator for Ubuntu';
  args: {
    task: string;
  };
  dynamic: true;
}

// ============================================================================
// Pattern 2: Dynamic Prompts (For conditional logic)
// ============================================================================

interface QuickReferencePrompt extends IPrompt {
  name: 'quickReference';
  description: 'Quick reference guide to all available prompts';
  args: {
    includeExamples?: boolean;
  };
  dynamic: true;  // Requires implementation
}

// ============================================================================
// Pattern 3: Hybrid - Combine Multiple Files
// ============================================================================

const headerContent = '# System Prompt Library\n\nAvailable prompts:\n\n';
const footerContent = '\n\n---\n*Generated by Simply MCP*';

interface PromptIndexTool extends IPrompt {
  name: 'promptIndex';
  description: 'Index of all available prompts';
  args: {};
  // Concatenate multiple sources
  template: headerContent + '1. Orchestrator\n2. Ubuntu Admin\n3. Quick Reference' + footerContent;
}

// ============================================================================
// Simple Tool Example
// ============================================================================

interface EchoTool extends ITool {
  name: 'echo';
  description: 'Echo back a message';
  params: {
    message: string;
  };
  result: string;
}

// ============================================================================
// Server Definition
// ============================================================================

interface FilePromptsServer extends IServer {
  name: 'file-prompts-demo';
  version: '1.0.0';
  description: 'Demonstrates loading prompts from files using Interface API';
}

// ============================================================================
// Server Implementation
// ============================================================================

export default class FilePromptsServerImpl implements FilePromptsServer {
  // Dynamic prompts from file content - implement as methods
  orchestrator: OrchestratorPromptTool = (args) => {
    let result = orchestratorPrompt;
    // Replace {task} and {context} placeholders
    result = result.replace('{task}', args.task);
    result = result.replace('{context}', args.context || 'No additional context provided');
    return result;
  };

  ubuntuAdmin: AdminPromptTool = (args) => {
    return adminPrompt.replace('{task}', args.task);
  };

  // Dynamic prompt with conditional logic
  quickReference: QuickReferencePrompt = (args) => {
    let content = '# Quick Reference\n\n';

    content += '## Available Prompts\n\n';
    content += '1. **orchestrator** - Agentic coding loop guide\n';
    content += '2. **ubuntu_admin** - Linux system administration\n';
    content += '3. **quick_reference** - This guide\n\n';

    if (args.includeExamples) {
      content += '## Example Usage\n\n';
      content += '```typescript\n';
      content += 'const response = await server.getPrompt("orchestrator", {\n';
      content += '  task: "Build a REST API",\n';
      content += '  context: "Using Express.js and TypeScript"\n';
      content += '});\n';
      content += '```\n';
    }

    return content;
  };

  // Tool implementation
  echo: EchoTool = async (params) => {
    return `Echo: ${params.message}`;
  };
}

// ============================================================================
// Best Practices Demonstrated
// ============================================================================

/**
 * ✅ DO:
 * - Load files into constants at module level
 * - Use string concatenation to combine content
 * - Use {variable} syntax for runtime argument interpolation
 * - Keep prompt files organized (e.g., in prompts/ directory)
 * - Mark complex prompts as dynamic: true
 *
 * ❌ DON'T:
 * - Use template literals with ${} for file content
 * - Load files inside interface definitions
 * - Mix compile-time and runtime string interpolation
 *
 * COMMON MISTAKE:
 * ```typescript
 * // ❌ WRONG - This triggers dynamic detection
 * const content = readFileSync('file.md', 'utf-8');
 * interface BadPrompt extends IPrompt {
 *   template: `${content}`;  // Parser sees ${} and marks as dynamic
 * }
 *
 * // ✅ CORRECT - Use concatenation
 * interface GoodPrompt extends IPrompt {
 *   template: content + '\n\nExtra text: {arg}';
 * }
 * ```
 */
