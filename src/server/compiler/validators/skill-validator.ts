/**
 * Skill Validator
 *
 * Main validation orchestrator that runs all skill validation rules
 * and aggregates warnings.
 */

import type { ValidationContext, ValidationWarning, ReferenceMaps } from './types.js';
import {
  checkOrphanedHiddenItems,
  checkInvalidReferences,
  checkNonHiddenComponents,
  checkEmptySkills,
  checkOrphanedSkillMembership
} from './rules/index.js';

/**
 * Build reference maps for fast lookup of skill-component relationships
 * Time complexity: O(S * C) where S = skills, C = avg components per skill
 */
function buildReferenceMaps(context: ValidationContext): ReferenceMaps {
  // Forward map: component → skills that reference it
  const componentToSkills = new Map<string, Set<string>>();

  // Reverse map: skill → components it references
  const skillToComponents = new Map<string, Set<string>>();

  for (const [skillName, skill] of context.skills) {
    // Only check auto-generated skills
    if (!skill.isAutoGenerated) continue;

    const components = new Set<string>();

    // Process tools
    if (skill.tools) {
      for (const toolName of skill.tools) {
        components.add(`tool:${toolName}`);

        if (!componentToSkills.has(`tool:${toolName}`)) {
          componentToSkills.set(`tool:${toolName}`, new Set());
        }
        componentToSkills.get(`tool:${toolName}`)!.add(skillName);
      }
    }

    // Process resources
    if (skill.resources) {
      for (const uri of skill.resources) {
        components.add(`resource:${uri}`);

        if (!componentToSkills.has(`resource:${uri}`)) {
          componentToSkills.set(`resource:${uri}`, new Set());
        }
        componentToSkills.get(`resource:${uri}`)!.add(skillName);
      }
    }

    // Process prompts
    if (skill.prompts) {
      for (const promptName of skill.prompts) {
        components.add(`prompt:${promptName}`);

        if (!componentToSkills.has(`prompt:${promptName}`)) {
          componentToSkills.set(`prompt:${promptName}`, new Set());
        }
        componentToSkills.get(`prompt:${promptName}`)!.add(skillName);
      }
    }

    skillToComponents.set(skillName, components);
  }

  return { componentToSkills, skillToComponents };
}

/**
 * Main validation orchestrator
 * Time complexity: O(T + R + P + S * C) where T = tools, R = resources,
 * P = prompts, S = skills, C = avg components per skill
 */
export function validateSkills(context: ValidationContext): ValidationWarning[] {
  const allWarnings: ValidationWarning[] = [];

  // Early exit if validation is disabled
  if (context.config.enabled === false) {
    return allWarnings;
  }

  // Step 1: Build reference maps
  const referenceMaps = buildReferenceMaps(context);

  // Step 2: Run each enabled rule
  if (context.config.rules?.orphanedHidden !== 'off') {
    allWarnings.push(...checkOrphanedHiddenItems(context, referenceMaps));
  }

  if (context.config.rules?.invalidReferences !== 'off') {
    allWarnings.push(...checkInvalidReferences(context));
  }

  if (context.config.rules?.nonHiddenComponents !== 'off') {
    allWarnings.push(...checkNonHiddenComponents(context));
  }

  if (context.config.rules?.emptySkills !== 'off') {
    allWarnings.push(...checkEmptySkills(context));
  }

  if (context.config.rules?.orphanedSkillMembership !== 'off') {
    allWarnings.push(...checkOrphanedSkillMembership(context));
  }

  return allWarnings;
}
