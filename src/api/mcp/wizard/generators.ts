/**
 * Code generation templates for wizard output
 *
 * Generates production-ready TypeScript code from wizard state
 */

import type { ServerConfig, CompletedTool, ParamDef } from './state.js';

/**
 * Generate Zod schema code from parameter definitions
 */
export function generateZodSchema(params: ParamDef[]): string {
  const fields: string[] = [];

  for (const param of params) {
    let zodType = mapTypeToZod(param.type);

    // Add optional modifier
    if (!param.required) {
      zodType += '.optional()';
    }

    // Add default value
    if (param.default !== undefined) {
      const defaultValue = typeof param.default === 'string'
        ? `'${param.default}'`
        : JSON.stringify(param.default);
      zodType += `.default(${defaultValue})`;
    }

    // Add description
    zodType += `.describe('${param.description}')`;

    fields.push(`  ${param.name}: ${zodType}`);
  }

  return `z.object({\n${fields.join(',\n')}\n})`;
}

/**
 * Map parameter type to Zod type
 */
function mapTypeToZod(type: string): string {
  switch (type) {
    case 'string':
      return 'z.string()';
    case 'number':
      return 'z.number()';
    case 'boolean':
      return 'z.boolean()';
    case 'array':
      return 'z.array(z.any())';
    case 'object':
      return 'z.object({})';
    case 'any':
      return 'z.any()';
    default:
      return 'z.any()';
  }
}

/**
 * Generate complete server code
 */
export function generateServerCode(config: {
  serverConfig: ServerConfig;
  tools: CompletedTool[];
  apiStyle: 'functional' | 'decorator' | 'programmatic';
}): string {
  const { serverConfig, tools, apiStyle } = config;

  if (apiStyle === 'functional') {
    return generateFunctionalServer(serverConfig, tools);
  } else if (apiStyle === 'decorator') {
    return generateDecoratorServer(serverConfig, tools);
  } else {
    return generateProgrammaticServer(serverConfig, tools);
  }
}

/**
 * Generate functional API server code
 */
function generateFunctionalServer(
  serverConfig: ServerConfig,
  tools: CompletedTool[]
): string {
  const toolsCode = tools.map(tool => generateToolCode(tool)).join(',\n\n');

  return `/**
 * ${serverConfig.name} - MCP Server
 * ${serverConfig.description || 'Generated by MCP Wizard'}
 *
 * Generated with SimplyMCP Wizard
 * https://github.com/Clockwork-Innovations/simply-mcp-ts
 */

import { defineMCP } from 'simply-mcp';
import { z } from 'zod';

export default defineMCP({
  name: '${serverConfig.name}',
  version: '${serverConfig.version}',
  ${serverConfig.description ? `description: '${serverConfig.description}',` : ''}

  tools: [
${toolsCode}
  ]
});
`;
}

/**
 * Generate code for a single tool (functional style)
 */
function generateToolCode(tool: CompletedTool): string {
  const paramNames = tool.parameters.map(p => p.name);
  const hasParams = paramNames.length > 0;

  return `    {
      name: '${tool.name}',
      description: '${tool.description}',
      parameters: ${tool.zodSchemaCode || 'z.object({})'},
      execute: async (${hasParams ? 'args' : '_args'}) => {
        // TODO: Implement tool logic
        ${tool.implementationNotes ? `// Implementation notes: ${tool.implementationNotes}` : ''}
        ${hasParams ? `// Available parameters: ${paramNames.join(', ')}` : ''}

        // Example implementation:
        // const result = processData(args);
        // return result;

        return 'Tool "${tool.name}" executed successfully! (Replace this with actual implementation)';
      }
    }`;
}

/**
 * Generate decorator API server code
 */
function generateDecoratorServer(
  serverConfig: ServerConfig,
  tools: CompletedTool[]
): string {
  const toolMethods = tools.map(tool => generateToolMethod(tool)).join('\n\n');

  return `/**
 * ${serverConfig.name} - MCP Server
 * ${serverConfig.description || 'Generated by MCP Wizard'}
 *
 * Generated with SimplyMCP Wizard
 * https://github.com/Clockwork-Innovations/simply-mcp-ts
 */

import { MCPServer, Tool } from 'simply-mcp';
import { z } from 'zod';

@MCPServer({
  name: '${serverConfig.name}',
  version: '${serverConfig.version}',
  ${serverConfig.description ? `description: '${serverConfig.description}'` : ''}
})
export default class ${toPascalCase(serverConfig.name || 'MyServer')} {
${toolMethods}
}
`;
}

/**
 * Generate decorator tool method
 */
function generateToolMethod(tool: CompletedTool): string {
  const paramNames = tool.parameters.map(p => p.name);
  const hasParams = paramNames.length > 0;

  return `  @Tool({
    description: '${tool.description}',
    parameters: ${tool.zodSchemaCode || 'z.object({})'}
  })
  async ${toCamelCase(tool.name)}(${hasParams ? 'args: any' : ''}) {
    // TODO: Implement tool logic
    ${tool.implementationNotes ? `// Implementation notes: ${tool.implementationNotes}` : ''}
    ${hasParams ? `// Available parameters: ${paramNames.join(', ')}` : ''}

    return 'Tool "${tool.name}" executed successfully! (Replace this with actual implementation)';
  }`;
}

/**
 * Generate programmatic API server code
 */
function generateProgrammaticServer(
  serverConfig: ServerConfig,
  tools: CompletedTool[]
): string {
  const addToolCalls = tools.map(tool => generateAddToolCall(tool)).join('\n\n');

  return `/**
 * ${serverConfig.name} - MCP Server
 * ${serverConfig.description || 'Generated by MCP Wizard'}
 *
 * Generated with SimplyMCP Wizard
 * https://github.com/Clockwork-Innovations/simply-mcp-ts
 */

import { BuildMCPServer } from 'simply-mcp';
import { z } from 'zod';

// Create server instance
const server = new BuildMCPServer({
  name: '${serverConfig.name}',
  version: '${serverConfig.version}',
  ${serverConfig.description ? `description: '${serverConfig.description}',` : ''}
});

// Register tools
${addToolCalls}

// Start server
await server.start();
`;
}

/**
 * Generate addTool call for programmatic API
 */
function generateAddToolCall(tool: CompletedTool): string {
  const paramNames = tool.parameters.map(p => p.name);
  const hasParams = paramNames.length > 0;

  return `server.addTool({
  name: '${tool.name}',
  description: '${tool.description}',
  parameters: ${tool.zodSchemaCode || 'z.object({})'},
  execute: async (${hasParams ? 'args' : '_args'}) => {
    // TODO: Implement tool logic
    ${tool.implementationNotes ? `// Implementation notes: ${tool.implementationNotes}` : ''}
    ${hasParams ? `// Available parameters: ${paramNames.join(', ')}` : ''}

    return 'Tool "${tool.name}" executed successfully! (Replace this with actual implementation)';
  }
});`;
}

/**
 * Helper: Convert kebab-case to camelCase
 */
function toCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Helper: Convert kebab-case to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}
