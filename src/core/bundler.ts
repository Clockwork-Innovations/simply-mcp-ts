/**
 * Main bundler implementation using esbuild
 * Feature 4: Bundling Command
 */

import type * as esbuildType from 'esbuild';
import { stat, readFile, chmod, writeFile, mkdtemp, rm } from 'fs/promises';
import { tmpdir } from 'os';
import { join, basename, dirname } from 'path';
import { BundleOptions, BundleResult, BundleError, BundleMetadata } from '../features/dependencies/bundle-types';
import { detectEntryPoint } from './entry-detector.js';
import { resolveDependencies, getBuiltinModules } from '../features/dependencies/dependency-resolver.js';
import { formatOutput } from './output-formatter.js';
import { createStandaloneBundle } from './formatters/standalone-formatter.js';
import { handleSourceMap } from './formatters/sourcemap-handler.js';
import { startWatch } from './formatters/watch-manager.js';
import { createArchive } from './archiver.js';
import { generateManifest, writeManifest } from './bundle-manifest.js';

/**
 * Bundle a SimplyMCP server using esbuild
 *
 * @param options - Bundle options
 * @returns Bundle result
 *
 * @example
 * ```typescript
 * const result = await bundle({
 *   entry: './server.ts',
 *   output: './dist/server.js',
 *   format: 'single-file',
 *   minify: true
 * });
 *
 * if (result.success) {
 *   console.log(`Bundled to ${result.outputPath} (${result.size} bytes)`);
 * }
 * ```
 */
export async function bundle(options: BundleOptions): Promise<BundleResult> {
  const startTime = Date.now();
  const warnings: string[] = [];
  const errors: BundleError[] = [];

  try {
    // Import esbuild with error handling
    let esbuild: typeof esbuildType;
    try {
      esbuild = await import('esbuild');
    } catch (error) {
      throw new Error(
        'Bundle command requires esbuild.\n' +
        'Install it with: npm install esbuild\n\n' +
        'Or use run command instead of bundle.'
      );
    }

    // 1. Detect and validate entry point
    const basePath = options.basePath || process.cwd();
    if (options.onProgress) {
      options.onProgress('Detecting entry point...');
    }

    const entry = await detectEntryPoint(options.entry, basePath);

    if (options.onProgress) {
      options.onProgress(`Entry point: ${entry}`);
    }

    // 2. Resolve dependencies
    if (options.onProgress) {
      options.onProgress('Resolving dependencies...');
    }

    const deps = await resolveDependencies({
      entryPoint: entry,
      autoInstall: options.autoInstall,
      basePath,
    });

    // Add warnings from inline dependencies
    if (deps.inlineDependencies.warnings.length > 0) {
      warnings.push(...deps.inlineDependencies.warnings);
    }

    if (deps.inlineDependencies.errors.length > 0) {
      deps.inlineDependencies.errors.forEach(err => {
        warnings.push(`Inline dependency error: ${err.message}`);
      });
    }

    // 3. Build esbuild configuration
    if (options.onProgress) {
      options.onProgress('Building bundle configuration...');
    }

    const { config: esbuildConfig, outfile: esbuildOutfile } = buildEsbuildConfig(options, entry, deps);

    // 4. Handle watch mode - delegate to watch-manager
    if (options.watch) {
      await startWatch({
        bundleOptions: { ...options, watch: false },
        poll: options.watchOptions?.poll,
        interval: options.watchOptions?.interval,
        ignored: options.watchOptions?.ignored,
        restart: options.watchOptions?.restart,
      });
      // Watch mode runs indefinitely, return a pending result
      return {
        success: true,
        outputPath: options.output,
        format: options.format || 'single-file',
        size: 0,
        duration: 0,
        warnings: [],
        errors: [],
      };
    }

    // 5. Run esbuild
    if (options.onProgress) {
      options.onProgress('Running esbuild...');
    }

    const result = await esbuild.build(esbuildConfig);

    // Post-process single-file bundles: add shebang and make executable
    if (options.format === 'single-file') {
      await addShebangAndMakeExecutable(options.output);
    }

    // 6. Handle source maps (Feature 4.2)
    if (options.sourcemap && result.metafile) {
      if (options.onProgress) {
        options.onProgress('Generating source maps...');
      }

      // Read the generated source map if esbuild created one
      const sourceMapPath = `${options.output}.map`;
      try {
        const sourceMapContent = await readFile(sourceMapPath, 'utf8');
        const mode = typeof options.sourcemap === 'boolean' ? 'external' : options.sourcemap;
        await handleSourceMap({
          bundlePath: options.output,
          sourceMapContent,
          mode,
        });
      } catch (err) {
        // Source map might not exist if esbuild didn't generate it
        if (options.onProgress) {
          options.onProgress('Source map generation skipped (not generated by esbuild)');
        }
      }
    }

    // 7. Extract warnings
    if (result.warnings.length > 0) {
      warnings.push(...result.warnings.map(w => formatEsbuildMessage(w)));
    }

    // 8. Build metadata (needed for archive formats)
    const metadata: BundleMetadata = {
      entry,
      moduleCount: result.metafile ? Object.keys(result.metafile.inputs).length : 0,
      dependencies: Object.keys(deps.dependencies),
      external: [
        ...deps.nativeModules,
        ...(options.external || []),
      ],
      nativeModules: deps.nativeModules,
    };

    // 9. Route to appropriate formatter based on format (Feature 4.2)
    let outputPath = options.output;
    let outputSize = 0;

    if (options.format === 'standalone') {
      if (options.onProgress) {
        options.onProgress('Creating standalone bundle...');
      }

      // Determine the bundle file path and output directory
      // If output ends with .js, use it as bundle and create -standalone directory
      // Otherwise, output is the directory and bundle.js is inside it
      let bundlePath: string;
      let outputDir: string;

      if (options.output.endsWith('.js')) {
        bundlePath = options.output;
        outputDir = options.output.replace(/\.js$/, '-standalone');
      } else {
        bundlePath = options.output + '/bundle.js';
        outputDir = options.output;
      }

      const standaloneResult = await createStandaloneBundle({
        bundlePath,
        outputDir,
        includeAssets: options.includeAssets,
        includeNativeModules: true,
        dependencies: deps.dependencies,
      });
      outputPath = standaloneResult.outputDir;
      outputSize = await getDirectorySize(standaloneResult.files);
    } else if (options.format === 'tar.gz' || options.format === 'zip') {
      // Archive formats: tar.gz and zip
      if (options.onProgress) {
        options.onProgress(`Creating ${options.format} archive...`);
      }

      const archiveResult = await createArchiveBundle({
        result,
        metadata,
        format: options.format,
        outputPath: options.output,
        basePath,
        deps,
        onProgress: options.onProgress,
        esbuildOutfile,
      });

      outputPath = archiveResult.outputPath;
      outputSize = archiveResult.size;
    } else {
      // Single-file, esm, or cjs format - already handled by esbuild
      outputSize = await getOutputSize(options.output);
    }

    // 10. Return successful result
    const duration = Date.now() - startTime;
    if (options.onProgress) {
      options.onProgress(`Bundle complete in ${duration}ms (${formatSize(outputSize)})`);
    }

    return {
      success: true,
      outputPath,
      format: options.format || 'single-file',
      size: outputSize,
      duration,
      warnings,
      errors: [],
      metadata,
    };
  } catch (error) {
    // Handle bundling error
    const bundleError: BundleError = {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    };

    errors.push(bundleError);

    if (options.onError) {
      options.onError(bundleError);
    }

    return {
      success: false,
      outputPath: options.output,
      format: options.format || 'single-file',
      size: 0,
      duration: Date.now() - startTime,
      warnings,
      errors,
    };
  }
}

/**
 * Build esbuild configuration from bundle options
 */
function buildEsbuildConfig(
  options: BundleOptions,
  entry: string,
  deps: any
): { config: esbuildType.BuildOptions; outfile: string } {
  const format = options.format || 'single-file';

  // Handle external dependencies based on format
  let external: string[];
  let banner: { js: string } | undefined;

  if (format === 'single-file') {
    // For single-file format: fail if native modules detected
    if (deps.nativeModules && deps.nativeModules.length > 0) {
      throw new Error(
        `Cannot create single-file bundle: native modules detected (${deps.nativeModules.join(', ')}). ` +
        `Native modules cannot be bundled into a single file. ` +
        `Please use 'standalone', 'tar.gz', or 'zip' format instead, which support native modules.`
      );
    }

    // Only externalize Node.js builtins (bundle all npm dependencies)
    external = [
      ...getBuiltinModules(),
      ...(options.external || []),
    ];

    // Don't add shebang via banner - we'll add it post-build to avoid duplication
    banner = options.banner ? { js: options.banner } : undefined;
  } else if (format === 'tar.gz' || format === 'zip') {
    // For archive formats: externalize builtins and native modules
    // Bundle all other dependencies into server.js
    external = [
      ...getBuiltinModules(), // Always external
      ...deps.nativeModules,  // Native modules must be external (installed via package.json)
      ...(options.external || []),
    ];

    banner = options.banner ? { js: options.banner } : undefined;
  } else {
    // For other formats: externalize builtins, native modules, and user-specified
    external = [
      ...getBuiltinModules(), // Always external
      ...deps.nativeModules,  // Native modules must be external
      ...(options.external || []),
    ];

    banner = options.banner ? { js: options.banner } : undefined;
  }

  // For standalone format, if output is a directory, write to bundle.js inside it
  // For archive formats, use a temporary file that will be included in the archive
  // This ensures esbuild has a valid file path
  let outfile = options.output;
  if (format === 'standalone' && !options.output.endsWith('.js')) {
    outfile = options.output + '/bundle.js';
  } else if (format === 'tar.gz' || format === 'zip') {
    // For archives, write to the specified output path (will be read and moved to archive)
    // Ensure it has .js extension for esbuild
    if (!options.output.endsWith('.js') && !options.output.endsWith('.tar.gz') && !options.output.endsWith('.zip')) {
      outfile = options.output + '.js';
    } else if (options.output.endsWith('.tar.gz') || options.output.endsWith('.zip')) {
      // Replace archive extension with .js for temporary build
      outfile = options.output.replace(/\.(tar\.gz|zip)$/, '.js');
    }
  }

  return {
    config: {
      entryPoints: [entry],
      bundle: true,
      platform: options.platform || 'node',
      target: options.target || 'node20',
      format: getEsbuildFormat(format),
      outfile,
      minify: options.minify !== false, // Default to true
      sourcemap: options.sourcemap || false,
      external: external,
      treeShaking: options.treeShake !== false, // Default to true
      metafile: true,
      logLevel: 'warning',
      mainFields: ['module', 'main'],
      conditions: ['node', 'import', 'require'],
      banner: banner,
      footer: options.footer ? { js: options.footer } : undefined,
    },
    outfile,
  };
}

/**
 * Convert bundle format to esbuild format
 */
function getEsbuildFormat(format: string): esbuildType.Format {
  switch (format) {
    case 'esm':
      return 'esm';
    case 'cjs':
      return 'cjs';
    case 'tar.gz':
    case 'zip':
      // Archive formats use ESM for better compatibility with dynamic imports
      return 'esm';
    case 'single-file':
    case 'standalone':
    case 'executable':
    default:
      return 'cjs'; // Default to CJS for compatibility
  }
}

/**
 * Bundle in watch mode
 */
async function bundleWatch(
  options: BundleOptions,
  esbuildConfig: esbuildType.BuildOptions
): Promise<BundleResult> {
  const startTime = Date.now();

  // Import esbuild with error handling
  let esbuild: typeof esbuildType;
  try {
    esbuild = await import('esbuild');
  } catch (error) {
    throw new Error(
      'Watch mode requires esbuild.\n' +
      'Install it with: npm install esbuild\n\n' +
      'Or run without --watch flag.'
    );
  }

  return new Promise((resolve) => {
    let isFirstBuild = true;

    const context = esbuild.context({
      ...esbuildConfig,
      plugins: [
        ...(esbuildConfig.plugins || []),
        {
          name: 'watch-plugin',
          setup(build) {
            build.onEnd((result) => {
              const warnings = result.warnings.map(w => formatEsbuildMessage(w));
              const errors = result.errors.map(e => ({
                message: formatEsbuildMessage(e),
                location: e.location ? {
                  file: e.location.file,
                  line: e.location.line,
                  column: e.location.column,
                } : undefined,
              }));

              if (options.onProgress) {
                if (errors.length > 0) {
                  options.onProgress(`Build failed with ${errors.length} error(s)`);
                } else {
                  options.onProgress(`Build successful (${warnings.length} warning(s))`);
                }
              }

              if (isFirstBuild) {
                isFirstBuild = false;
                resolve({
                  success: errors.length === 0,
                  outputPath: options.output,
                  format: options.format || 'single-file',
                  size: 0,
                  duration: Date.now() - startTime,
                  warnings,
                  errors,
                });
              }
            });
          },
        },
      ],
    });

    context.then(ctx => {
      ctx.watch();
      if (options.onProgress) {
        options.onProgress('Watching for changes...');
      }
    });
  });
}

/**
 * Get output file size
 */
async function getOutputSize(outputPath: string): Promise<number> {
  try {
    const stats = await stat(outputPath);
    return stats.size;
  } catch {
    return 0;
  }
}

/**
 * Get total size of multiple files (for standalone format)
 */
async function getDirectorySize(filePaths: string[]): Promise<number> {
  let totalSize = 0;
  for (const filePath of filePaths) {
    try {
      const stats = await stat(filePath);
      totalSize += stats.size;
    } catch {
      // Skip files that don't exist
    }
  }
  return totalSize;
}

/**
 * Format esbuild message (warning or error)
 */
function formatEsbuildMessage(msg: esbuildType.Message): string {
  let formatted = msg.text;

  if (msg.location) {
    formatted = `${msg.location.file}:${msg.location.line}:${msg.location.column}: ${formatted}`;
  }

  if (msg.notes && msg.notes.length > 0) {
    formatted += '\n' + msg.notes.map(note => `  Note: ${note.text}`).join('\n');
  }

  return formatted;
}

/**
 * Format bytes to human-readable size
 */
function formatSize(bytes: number): string {
  if (bytes < 1024) {
    return `${bytes} B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

/**
 * Stop watching (for watch mode)
 * Note: This would need to be exposed via a context object
 */
export async function stopWatch(context: esbuildType.BuildContext): Promise<void> {
  await context.dispose();
}

/**
 * Create archive bundle (tar.gz or zip)
 * Creates a temporary directory with bundle contents, generates manifest,
 * and creates the archive
 */
async function createArchiveBundle(params: {
  result: esbuildType.BuildResult;
  metadata: BundleMetadata;
  format: 'tar.gz' | 'zip';
  outputPath: string;
  esbuildOutfile: string;
  basePath: string;
  deps: any;
  onProgress?: (message: string) => void;
}): Promise<{ outputPath: string; size: number }> {
  const { result, metadata, format, outputPath, esbuildOutfile, basePath, deps, onProgress } = params;

  // Create temporary directory for bundle contents
  const tempDir = await mkdtemp(join(tmpdir(), 'simplemcp-bundle-'));

  try {
    // 1. Write compiled server.js from esbuild output
    if (onProgress) {
      onProgress('Writing compiled server code...');
    }

    const serverJsPath = join(tempDir, 'server.js');
    if (result.outputFiles && result.outputFiles.length > 0) {
      // When using write: false, output is in outputFiles
      await writeFile(serverJsPath, result.outputFiles[0].contents);
    } else {
      // When using write: true (default), read from disk
      // Use the esbuild outfile path
      const compiledCode = await readFile(esbuildOutfile, 'utf-8');
      await writeFile(serverJsPath, compiledCode);
    }

    // 2. Read package.json for server metadata (if it exists)
    if (onProgress) {
      onProgress('Reading server metadata...');
    }

    let serverName = basename(metadata.entry, '.ts').replace(/\.js$/, '');
    let serverVersion = '1.0.0';
    let serverDescription: string | undefined;

    try {
      const packageJsonPath = join(basePath, 'package.json');
      const packageJsonContent = await readFile(packageJsonPath, 'utf-8');
      const packageJson = JSON.parse(packageJsonContent);

      if (packageJson.name) {
        serverName = packageJson.name;
      }
      if (packageJson.version) {
        serverVersion = packageJson.version;
      }
      if (packageJson.description) {
        serverDescription = packageJson.description;
      }
    } catch (error) {
      // package.json doesn't exist or is invalid, use defaults
      if (onProgress) {
        onProgress('No package.json found, using default metadata');
      }
    }

    // 3. Generate and write bundle manifest
    if (onProgress) {
      onProgress('Generating bundle manifest...');
    }

    const manifest = generateManifest(
      {
        name: serverName,
        version: serverVersion,
        description: serverDescription,
      },
      metadata.nativeModules,
      'server.js'
    );

    await writeManifest(tempDir, manifest);

    // 4. Create package.json for native dependencies (if needed)
    if (metadata.nativeModules.length > 0) {
      if (onProgress) {
        onProgress('Creating package.json for native dependencies...');
      }

      const bundlePackageJson = {
        name: serverName,
        version: serverVersion,
        description: serverDescription,
        private: true,
        dependencies: metadata.nativeModules.reduce((acc, dep) => {
          // Use the version from resolved dependencies if available
          acc[dep] = deps.dependencies[dep] || 'latest';
          return acc;
        }, {} as Record<string, string>),
      };

      await writeFile(
        join(tempDir, 'package.json'),
        JSON.stringify(bundlePackageJson, null, 2),
        'utf-8'
      );
    }

    // 5. Determine archive output path
    // If outputPath doesn't have the correct extension, add it
    let archivePath = outputPath;
    if (format === 'tar.gz' && !outputPath.endsWith('.tar.gz')) {
      archivePath = outputPath.replace(/\.[^.]*$/, '') + '.tar.gz';
    } else if (format === 'zip' && !outputPath.endsWith('.zip')) {
      archivePath = outputPath.replace(/\.[^.]*$/, '') + '.zip';
    }

    // Ensure output directory exists
    const archiveDir = dirname(archivePath);
    try {
      await stat(archiveDir);
    } catch {
      throw new Error(`Output directory does not exist: ${archiveDir}`);
    }

    // 6. Create the archive
    if (onProgress) {
      onProgress(`Creating ${format} archive...`);
    }

    await createArchive({
      format,
      sourceDir: tempDir,
      outputPath: archivePath,
    });

    // 7. Get archive size
    const archiveSize = await getOutputSize(archivePath);

    if (onProgress) {
      onProgress(`Archive created: ${archivePath} (${formatSize(archiveSize)})`);
    }

    // 8. Clean up temporary esbuild output file if it's different from final archive
    if (esbuildOutfile !== archivePath) {
      try {
        await rm(esbuildOutfile, { force: true });
      } catch (error) {
        // Ignore cleanup errors
      }
    }

    return {
      outputPath: archivePath,
      size: archiveSize,
    };
  } finally {
    // Clean up temporary directory
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
      console.warn(`Failed to clean up temporary directory ${tempDir}:`, error);
    }
  }
}

/**
 * Add shebang to file and make it executable
 * This is done post-build to avoid duplication issues with esbuild's banner
 */
async function addShebangAndMakeExecutable(filePath: string): Promise<void> {
  // Read current content
  const content = await readFile(filePath, 'utf-8');

  // Only add shebang if it doesn't already exist
  if (!content.startsWith('#!')) {
    const withShebang = '#!/usr/bin/env node\n' + content;
    await writeFile(filePath, withShebang);
  }

  // Make executable
  await chmod(filePath, 0o755);
}
