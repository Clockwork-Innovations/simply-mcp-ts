{
  "version": 3,
  "sources": ["../../../src/client/hooks/useMCPTool.ts", "../../../src/client/hooks/MCPProvider.tsx", "../../../src/client/hooks/useMCPToolHelpers.ts", "../../../src/client/hooks/usePromptSubmit.ts", "../../../src/client/hooks/useIntent.ts", "../../../src/client/hooks/useNotify.ts", "../../../src/client/hooks/useOpenLink.ts"],
  "sourcesContent": ["/**\n * useMCPTool Hook - Declarative MCP Tool Calling for React\n *\n * Makes it trivial to call MCP tools from any React component without boilerplate.\n * Works seamlessly with any UI library (shadcn, Radix, MUI, native HTML, etc.)\n *\n * Features:\n * - Automatic loading/error/data state management\n * - Optimistic updates support\n * - TypeScript type inference\n * - Request deduplication\n * - Automatic retries (optional)\n *\n * @example\n * ```tsx\n * import { useMCPTool } from 'simply-mcp/client';\n * import { Button } from '@/components/ui/button'; // Any button works!\n *\n * function SearchUI() {\n *   const search = useMCPTool('search_products', {\n *     onSuccess: (data) => console.log('Found:', data),\n *     optimistic: true\n *   });\n *\n *   return (\n *     <Button\n *       onClick={() => search.execute({ query: 'laptop' })}\n *       disabled={search.loading}\n *     >\n *       {search.loading ? 'Searching...' : 'Search'}\n *     </Button>\n *   );\n * }\n * ```\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { useMergedOptions } from './MCPProvider.js';\n\n/**\n * MCP Tool Result (matches MCP protocol)\n */\nexport interface MCPToolResult {\n  content: Array<{\n    type: 'text' | 'image' | 'resource';\n    text?: string;\n    data?: string;\n    mimeType?: string;\n  }>;\n  isError?: boolean;\n}\n\n/**\n * Hook options for useMCPTool\n */\nexport interface UseMCPToolOptions<TData = any, TContext = unknown> {\n  /**\n   * Called when tool execution succeeds\n   */\n  onSuccess?: (data: TData, result: MCPToolResult) => void;\n\n  /**\n   * Called when tool execution fails\n   * Receives context returned from onMutate for rollback\n   */\n  onError?: (error: Error, params: any, context?: TContext) => void;\n\n  /**\n   * Called before execution starts (for optimistic updates)\n   * Return a context object that will be passed to onError for rollback\n   */\n  onMutate?: (params: any) => TContext | Promise<TContext> | void | Promise<void>;\n\n  /**\n   * Enable optimistic loading state (true by default)\n   */\n  optimistic?: boolean;\n\n  /**\n   * Parse the result content automatically\n   * - 'json': Parse first text content as JSON\n   * - 'text': Return first text content as string\n   * - 'raw': Return full MCPToolResult\n   * @default 'json'\n   */\n  parseAs?: 'json' | 'text' | 'raw';\n\n  /**\n   * Retry failed requests\n   * @default 0\n   */\n  retries?: number;\n\n  /**\n   * Retry delay in milliseconds\n   * @default 1000\n   */\n  retryDelay?: number;\n\n  /**\n   * Deduplicate simultaneous requests with same params\n   * @default true\n   */\n  deduplicate?: boolean;\n}\n\n/**\n * Hook return value\n */\nexport interface UseMCPToolResult<TData = any> {\n  /**\n   * Execute the tool with given parameters\n   */\n  execute: (params?: any) => Promise<TData>;\n\n  /**\n   * Current loading state\n   */\n  loading: boolean;\n\n  /**\n   * Parsed data from last successful execution\n   */\n  data: TData | null;\n\n  /**\n   * Error from last failed execution\n   */\n  error: Error | null;\n\n  /**\n   * Reset state to initial values\n   */\n  reset: () => void;\n\n  /**\n   * Whether tool has been called at least once\n   */\n  called: boolean;\n}\n\n/**\n * Parse MCP tool result based on parseAs option\n */\nfunction parseResult<TData>(result: MCPToolResult, parseAs: 'json' | 'text' | 'raw'): TData {\n  if (parseAs === 'raw') {\n    return result as any;\n  }\n\n  const firstContent = result.content?.[0];\n  if (!firstContent) {\n    throw new Error('No content in tool result');\n  }\n\n  const text = firstContent.text || '';\n\n  if (parseAs === 'json') {\n    try {\n      return JSON.parse(text) as TData;\n    } catch (e) {\n      throw new Error(`Failed to parse tool result as JSON: ${e.message}`);\n    }\n  }\n\n  // parseAs === 'text'\n  return text as any;\n}\n\n/**\n * Generate cache key for deduplication\n */\nfunction getCacheKey(toolName: string, params: any): string {\n  return `${toolName}:${JSON.stringify(params)}`;\n}\n\n/**\n * React Hook for calling MCP tools with automatic state management\n *\n * @param toolName - Name of the MCP tool to call\n * @param options - Hook configuration options\n * @returns Tool execution state and methods\n *\n * @example\n * ```tsx\n * // Simple usage\n * const search = useMCPTool('search');\n *\n * // With type inference\n * interface SearchResult {\n *   products: Array<{ id: string; name: string }>;\n * }\n * const search = useMCPTool<SearchResult>('search');\n *\n * // With callbacks\n * const search = useMCPTool('search', {\n *   onSuccess: (data) => console.log('Success:', data),\n *   onError: (err) => console.error('Error:', err),\n *   parseAs: 'json'\n * });\n *\n * // Execute the tool\n * await search.execute({ query: 'laptop' });\n * ```\n */\nexport function useMCPTool<TData = any>(\n  toolName: string,\n  hookOptions: UseMCPToolOptions<TData> = {}\n): UseMCPToolResult<TData> {\n  // Merge with context defaults (if MCPProvider is used)\n  const options = useMergedOptions(toolName, hookOptions);\n\n  const {\n    onSuccess,\n    onError,\n    onMutate,\n    optimistic = true,\n    parseAs = 'json',\n    retries = 0,\n    retryDelay = 1000,\n    deduplicate = true,\n  } = options;\n\n  // State\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState<TData | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [called, setCalled] = useState(false);\n\n  // Ref for in-flight requests (deduplication)\n  const inflightRef = useRef<Map<string, Promise<TData>>>(new Map());\n\n  // Ref to track if component is mounted (prevent state updates after unmount)\n  const isMountedRef = useRef(true);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n      inflightRef.current.clear();\n    };\n  }, []);\n\n  /**\n   * Execute the tool with retry logic\n   */\n  const executeWithRetry = useCallback(async (params: any, attempt: number = 0): Promise<MCPToolResult> => {\n    try {\n      // Check if window.callTool exists\n      if (typeof window === 'undefined' || !window.callTool) {\n        throw new Error('window.callTool is not available. Are you running in an MCP UI context?');\n      }\n\n      const result = await window.callTool(toolName, params);\n\n      // Check for error result\n      if (result.isError) {\n        const errorText = result.content?.[0]?.text || 'Tool execution failed';\n        throw new Error(errorText);\n      }\n\n      return result;\n    } catch (err) {\n      // Retry logic\n      if (attempt < retries) {\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return executeWithRetry(params, attempt + 1);\n      }\n      throw err;\n    }\n  }, [toolName, retries, retryDelay]);\n\n  /**\n   * Execute the tool\n   */\n  const execute = useCallback(async (params: any = {}): Promise<TData> => {\n    // Deduplication check\n    const cacheKey = deduplicate ? getCacheKey(toolName, params) : null;\n    if (cacheKey && inflightRef.current.has(cacheKey)) {\n      return inflightRef.current.get(cacheKey)!;\n    }\n\n    // Create execution promise\n    const executionPromise = (async () => {\n      let context: any = undefined;\n\n      try {\n        // Mark as called (safe - happens before async)\n        setCalled(true);\n\n        // Optimistic state update\n        if (optimistic) {\n          setLoading(true);\n          setError(null);\n        }\n\n        // Call onMutate for optimistic updates\n        // Capture context for potential rollback\n        if (onMutate) {\n          context = await onMutate(params);\n        }\n\n        // Execute tool with retries\n        const result = await executeWithRetry(params);\n\n        // Parse result\n        const parsedData = parseResult<TData>(result, parseAs);\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setData(parsedData);\n          setError(null);\n          setLoading(false);\n\n          // Call success callback\n          if (onSuccess) {\n            onSuccess(parsedData, result);\n          }\n        }\n\n        return parsedData;\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setError(error);\n          setData(null);\n          setLoading(false);\n\n          // Call error callback with context for rollback\n          if (onError) {\n            onError(error, params, context);\n          }\n        }\n\n        throw error;\n      } finally {\n        // Remove from inflight cache\n        if (cacheKey) {\n          inflightRef.current.delete(cacheKey);\n        }\n      }\n    })();\n\n    // Add to inflight cache\n    if (cacheKey) {\n      inflightRef.current.set(cacheKey, executionPromise);\n    }\n\n    return executionPromise;\n  }, [toolName, optimistic, onMutate, onSuccess, onError, executeWithRetry, parseAs, deduplicate]);\n\n  /**\n   * Reset hook state\n   */\n  const reset = useCallback(() => {\n    if (isMountedRef.current) {\n      setLoading(false);\n      setData(null);\n      setError(null);\n      setCalled(false);\n      inflightRef.current.clear();\n    }\n  }, []);\n\n  return {\n    execute,\n    loading,\n    data,\n    error,\n    reset,\n    called,\n  };\n}\n\n/**\n * Type declarations for window.callTool\n * (Auto-injected by simply-mcp)\n */\ndeclare global {\n  interface Window {\n    callTool: (toolName: string, params: any) => Promise<MCPToolResult>;\n    notify: (level: 'info' | 'success' | 'warning' | 'error', message: string) => void;\n    submitPrompt: (promptText: string) => void;\n    triggerIntent: (intent: string, params?: any) => void;\n    openLink: (url: string) => void;\n  }\n}\n", "/**\n * MCPProvider - Context Provider for MCP UI Configuration\n *\n * Optional provider for configuring global defaults for MCP tool hooks.\n * Not required - hooks work fine without it, but useful for setting\n * global error handlers, default parsing, etc.\n *\n * @example\n * ```tsx\n * import { MCPProvider } from 'simply-mcp/client';\n *\n * function App() {\n *   return (\n *     <MCPProvider\n *       onError={(err) => toast.error(err.message)}\n *       parseAs=\"json\"\n *     >\n *       <YourUI />\n *     </MCPProvider>\n *   );\n * }\n * ```\n */\n\nimport React, { createContext, useContext, ReactNode } from 'react';\nimport type { UseMCPToolOptions } from './useMCPTool.js';\n\n/**\n * MCP Context value\n */\nexport interface MCPContextValue {\n  /**\n   * Default options for all useMCPTool hooks\n   */\n  defaultOptions: UseMCPToolOptions;\n\n  /**\n   * Global error handler (called for all tool errors)\n   */\n  onError?: (error: Error, toolName: string) => void;\n\n  /**\n   * Global success handler (called for all tool successes)\n   */\n  onSuccess?: (data: any, toolName: string) => void;\n}\n\n/**\n * Default context value\n */\nconst defaultContextValue: MCPContextValue = {\n  defaultOptions: {\n    optimistic: true,\n    parseAs: 'json',\n    retries: 0,\n  },\n};\n\n/**\n * MCP Context\n */\nconst MCPContext = createContext<MCPContextValue>(defaultContextValue);\n\n/**\n * MCP Provider Props\n */\nexport interface MCPProviderProps {\n  /**\n   * Child components\n   */\n  children: ReactNode;\n\n  /**\n   * Default options for all tool hooks\n   */\n  defaultOptions?: Partial<UseMCPToolOptions>;\n\n  /**\n   * Global error handler\n   */\n  onError?: (error: Error, toolName: string) => void;\n\n  /**\n   * Global success handler\n   */\n  onSuccess?: (data: any, toolName: string) => void;\n\n  /**\n   * Default parse mode ('json' | 'text' | 'raw')\n   * @default 'json'\n   */\n  parseAs?: 'json' | 'text' | 'raw';\n\n  /**\n   * Enable optimistic updates by default\n   * @default true\n   */\n  optimistic?: boolean;\n\n  /**\n   * Default retry count\n   * @default 0\n   */\n  retries?: number;\n\n  /**\n   * Default retry delay in ms\n   * @default 1000\n   */\n  retryDelay?: number;\n}\n\n/**\n * MCP Provider Component\n *\n * Provides global configuration for MCP tool hooks.\n *\n * @param props - Provider props\n *\n * @example\n * ```tsx\n * // Basic usage with global error handler\n * <MCPProvider onError={(err) => console.error(err)}>\n *   <App />\n * </MCPProvider>\n *\n * // With toast notifications\n * <MCPProvider\n *   onError={(err, toolName) => toast.error(`${toolName} failed: ${err.message}`)}\n *   onSuccess={(data, toolName) => toast.success(`${toolName} succeeded`)}\n * >\n *   <App />\n * </MCPProvider>\n *\n * // With custom defaults\n * <MCPProvider\n *   parseAs=\"text\"\n *   optimistic={false}\n *   retries={3}\n *   retryDelay={2000}\n * >\n *   <App />\n * </MCPProvider>\n * ```\n */\nexport function MCPProvider({\n  children,\n  defaultOptions = {},\n  onError,\n  onSuccess,\n  parseAs,\n  optimistic,\n  retries,\n  retryDelay,\n}: MCPProviderProps) {\n  // Merge props into defaultOptions\n  const mergedOptions: UseMCPToolOptions = {\n    ...defaultContextValue.defaultOptions,\n    ...defaultOptions,\n    ...(parseAs !== undefined && { parseAs }),\n    ...(optimistic !== undefined && { optimistic }),\n    ...(retries !== undefined && { retries }),\n    ...(retryDelay !== undefined && { retryDelay }),\n  };\n\n  const value: MCPContextValue = {\n    defaultOptions: mergedOptions,\n    onError,\n    onSuccess,\n  };\n\n  return <MCPContext.Provider value={value}>{children}</MCPContext.Provider>;\n}\n\n/**\n * Hook to access MCP context\n *\n * @returns Current MCP context value\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const mcp = useMCPContext();\n *   console.log('Default options:', mcp.defaultOptions);\n * }\n * ```\n */\nexport function useMCPContext(): MCPContextValue {\n  return useContext(MCPContext);\n}\n\n/**\n * Hook to get merged options (context defaults + hook options)\n *\n * @param toolName - Name of the tool\n * @param hookOptions - Options passed to the hook\n * @returns Merged options\n *\n * @internal\n */\nexport function useMergedOptions(\n  toolName: string,\n  hookOptions: UseMCPToolOptions = {}\n): UseMCPToolOptions {\n  const context = useMCPContext();\n\n  // Merge context defaults with hook options\n  // Hook options take precedence\n  const merged: UseMCPToolOptions = {\n    ...context.defaultOptions,\n    ...hookOptions,\n  };\n\n  // Wrap callbacks to call both global and hook-specific handlers\n  if (context.onError || hookOptions.onError) {\n    const contextError = context.onError;\n    const hookError = hookOptions.onError;\n\n    merged.onError = (error: Error, params: any, hookContext?: any) => {\n      contextError?.(error, toolName);\n      hookError?.(error, params, hookContext);\n    };\n  }\n\n  if (context.onSuccess || hookOptions.onSuccess) {\n    const contextSuccess = context.onSuccess;\n    const hookSuccess = hookOptions.onSuccess;\n\n    merged.onSuccess = (data: any, result: any) => {\n      contextSuccess?.(data, toolName);\n      hookSuccess?.(data, result);\n    };\n  }\n\n  return merged;\n}\n", "/**\n * MCP Tool Helper Utilities\n *\n * Utility functions for working with multiple useMCPTool results.\n * These helpers accept arrays of tool results and provide aggregate operations.\n *\n * @example\n * ```tsx\n * import { useMCPTool, isAnyLoading, hasAnyError } from 'simply-mcp/client';\n *\n * function Dashboard() {\n *   const search = useMCPTool('search');\n *   const add = useMCPTool('add_to_cart');\n *   const stats = useMCPTool('get_stats');\n *\n *   const tools = [search, add, stats];\n *\n *   if (isAnyLoading(tools)) {\n *     return <div>Loading...</div>;\n *   }\n *\n *   if (hasAnyError(tools)) {\n *     const errors = getAllErrors(tools);\n *     return <div>Errors: {errors.map(e => e.message).join(', ')}</div>;\n *   }\n *\n *   return (\n *     <div>\n *       <button onClick={() => search.execute({ query: 'laptop' })}>Search</button>\n *       <button onClick={() => add.execute({ id: '123' })}>Add to Cart</button>\n *     </div>\n *   );\n * }\n * ```\n */\n\nimport type { UseMCPToolResult } from './useMCPTool.js';\n\n/**\n * Check if any tools are loading\n *\n * @param tools - Array of tool results from useMCPTool\n * @returns true if any tool is loading\n *\n * @example\n * ```tsx\n * const search = useMCPTool('search');\n * const add = useMCPTool('add');\n *\n * if (isAnyLoading([search, add])) {\n *   return <div>Loading...</div>;\n * }\n * ```\n */\nexport function isAnyLoading(tools: UseMCPToolResult<any>[]): boolean {\n  return tools.some((tool) => tool.loading);\n}\n\n/**\n * Check if all tools are loading\n *\n * @param tools - Array of tool results from useMCPTool\n * @returns true if all tools are loading\n *\n * @example\n * ```tsx\n * const search = useMCPTool('search');\n * const add = useMCPTool('add');\n *\n * if (areAllLoading([search, add])) {\n *   return <div>All operations in progress...</div>;\n * }\n * ```\n */\nexport function areAllLoading(tools: UseMCPToolResult<any>[]): boolean {\n  return tools.length > 0 && tools.every((tool) => tool.loading);\n}\n\n/**\n * Check if any tools have errors\n *\n * @param tools - Array of tool results from useMCPTool\n * @returns true if any tool has an error\n *\n * @example\n * ```tsx\n * const search = useMCPTool('search');\n * const add = useMCPTool('add');\n *\n * if (hasAnyError([search, add])) {\n *   return <div>Something went wrong!</div>;\n * }\n * ```\n */\nexport function hasAnyError(tools: UseMCPToolResult<any>[]): boolean {\n  return tools.some((tool) => tool.error !== null);\n}\n\n/**\n * Get all errors from tools\n *\n * @param tools - Array of tool results from useMCPTool\n * @returns Array of errors (non-null only)\n *\n * @example\n * ```tsx\n * const search = useMCPTool('search');\n * const add = useMCPTool('add');\n *\n * const errors = getAllErrors([search, add]);\n * if (errors.length > 0) {\n *   return (\n *     <div>\n *       {errors.map((err, i) => (\n *         <div key={i}>{err.message}</div>\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function getAllErrors(tools: UseMCPToolResult<any>[]): Error[] {\n  return tools.map((tool) => tool.error).filter((error): error is Error => error !== null);\n}\n\n/**\n * Reset all tools to their initial state\n *\n * @param tools - Array of tool results from useMCPTool\n *\n * @example\n * ```tsx\n * const search = useMCPTool('search');\n * const add = useMCPTool('add');\n *\n * const tools = [search, add];\n *\n * // Later...\n * <button onClick={() => resetAllTools(tools)}>\n *   Clear All\n * </button>\n * ```\n */\nexport function resetAllTools(tools: UseMCPToolResult<any>[]): void {\n  tools.forEach((tool) => tool.reset());\n}\n", "/**\n * usePromptSubmit Hook - Submit Prompts to LLM\n *\n * Hook for submitting prompts to the LLM during MCP UI interactions.\n * Provides state tracking, history management, and callback support.\n *\n * @example\n * ```tsx\n * import { usePromptSubmit } from 'simply-mcp/client';\n * import { Button } from '@/components/ui/button';\n *\n * function AIAssistant() {\n *   const prompt = usePromptSubmit({\n *     onSubmit: (text) => console.log('Submitted:', text)\n *   });\n *\n *   return (\n *     <div>\n *       <Button\n *         onClick={() => prompt.submit('Analyze this data')}\n *         disabled={prompt.submitting}\n *       >\n *         Ask AI\n *       </Button>\n *       {prompt.lastPrompt && <div>Last: {prompt.lastPrompt}</div>}\n *     </div>\n *   );\n * }\n * ```\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n/**\n * Options for usePromptSubmit hook\n */\nexport interface UsePromptSubmitOptions {\n  /**\n   * Called when prompt is submitted\n   */\n  onSubmit?: (prompt: string) => void;\n\n  /**\n   * Called when submission fails\n   */\n  onError?: (error: Error, prompt: string) => void;\n\n  /**\n   * Track prompt history\n   * @default true\n   */\n  trackHistory?: boolean;\n\n  /**\n   * Maximum history size\n   * @default 50\n   */\n  maxHistorySize?: number;\n\n  /**\n   * Prevent duplicate consecutive submissions\n   * @default true\n   */\n  preventDuplicates?: boolean;\n}\n\n/**\n * Return value from usePromptSubmit hook\n */\nexport interface UsePromptSubmitResult {\n  /**\n   * Submit a prompt to the LLM\n   */\n  submit: (prompt: string) => void;\n\n  /**\n   * Whether a submission is in progress\n   */\n  submitting: boolean;\n\n  /**\n   * Last submitted prompt\n   */\n  lastPrompt: string | null;\n\n  /**\n   * History of submitted prompts\n   */\n  history: string[];\n\n  /**\n   * Clear submission history\n   */\n  clearHistory: () => void;\n\n  /**\n   * Error from last submission\n   */\n  error: Error | null;\n}\n\n/**\n * Hook for submitting prompts to the LLM\n *\n * @param options - Hook configuration options\n * @returns Prompt submission state and methods\n *\n * @example\n * ```tsx\n * // Basic usage\n * const prompt = usePromptSubmit();\n * prompt.submit('Analyze this data');\n *\n * // With callbacks\n * const prompt = usePromptSubmit({\n *   onSubmit: (text) => console.log('Sent:', text),\n *   onError: (err) => console.error('Failed:', err)\n * });\n *\n * // With history tracking\n * const prompt = usePromptSubmit({\n *   trackHistory: true,\n *   maxHistorySize: 100\n * });\n * console.log('Recent prompts:', prompt.history);\n * ```\n */\nexport function usePromptSubmit(\n  options: UsePromptSubmitOptions = {}\n): UsePromptSubmitResult {\n  const {\n    onSubmit,\n    onError,\n    trackHistory = true,\n    maxHistorySize = 50,\n    preventDuplicates = true,\n  } = options;\n\n  const [submitting, setSubmitting] = useState(false);\n  const [lastPrompt, setLastPrompt] = useState<string | null>(null);\n  const [history, setHistory] = useState<string[]>([]);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Ref to track if component is mounted\n  const isMountedRef = useRef(true);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * Submit a prompt\n   */\n  const submit = useCallback(\n    (prompt: string) => {\n      try {\n        // Validate input\n        if (typeof prompt !== 'string' || !prompt.trim()) {\n          throw new Error('Prompt must be a non-empty string');\n        }\n\n        const trimmedPrompt = prompt.trim();\n\n        // Check for duplicates\n        if (preventDuplicates && trimmedPrompt === lastPrompt) {\n          console.warn('Duplicate prompt submission prevented:', trimmedPrompt);\n          return;\n        }\n\n        // Check if window.submitPrompt exists\n        if (typeof window === 'undefined' || !window.submitPrompt) {\n          throw new Error(\n            'window.submitPrompt is not available. Are you running in an MCP UI context?'\n          );\n        }\n\n        // Mark as submitting\n        setSubmitting(true);\n        setError(null);\n\n        // Submit prompt\n        window.submitPrompt(trimmedPrompt);\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setLastPrompt(trimmedPrompt);\n          setSubmitting(false);\n\n          // Track in history\n          if (trackHistory) {\n            setHistory((prev) => {\n              const newHistory = [trimmedPrompt, ...prev];\n              // Limit history size\n              return newHistory.slice(0, maxHistorySize);\n            });\n          }\n\n          // Call success callback\n          if (onSubmit) {\n            onSubmit(trimmedPrompt);\n          }\n        }\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setError(error);\n          setSubmitting(false);\n\n          // Call error callback\n          if (onError) {\n            onError(error, prompt);\n          }\n        }\n      }\n    },\n    [lastPrompt, trackHistory, maxHistorySize, preventDuplicates, onSubmit, onError]\n  );\n\n  /**\n   * Clear history\n   */\n  const clearHistory = useCallback(() => {\n    setHistory([]);\n  }, []);\n\n  return {\n    submit,\n    submitting,\n    lastPrompt,\n    history,\n    clearHistory,\n    error,\n  };\n}\n", "/**\n * useIntent Hook - Trigger Application Intents\n *\n * Hook for triggering application intents (navigation, file operations, etc.)\n * from MCP UI components. Provides state tracking and callback support.\n *\n * @example\n * ```tsx\n * import { useIntent } from 'simply-mcp/client';\n * import { Button } from '@/components/ui/button';\n *\n * function Navigation() {\n *   const navigate = useIntent('navigate', {\n *     onTrigger: (params) => console.log('Navigating:', params)\n *   });\n *\n *   return (\n *     <Button\n *       onClick={() => navigate.trigger({ page: 'settings' })}\n *       disabled={navigate.triggering}\n *     >\n *       Go to Settings\n *     </Button>\n *   );\n * }\n * ```\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n/**\n * Options for useIntent hook\n */\nexport interface UseIntentOptions {\n  /**\n   * Called when intent is triggered\n   */\n  onTrigger?: (params: any) => void;\n\n  /**\n   * Called when trigger fails\n   */\n  onError?: (error: Error, intent: string, params: any) => void;\n\n  /**\n   * Track intent history\n   * @default true\n   */\n  trackHistory?: boolean;\n\n  /**\n   * Maximum history size\n   * @default 50\n   */\n  maxHistorySize?: number;\n\n  /**\n   * Debounce rapid triggers (ms)\n   * @default 0\n   */\n  debounce?: number;\n}\n\n/**\n * Intent history entry\n */\nexport interface IntentHistoryEntry {\n  intent: string;\n  params: any;\n  timestamp: number;\n}\n\n/**\n * Return value from useIntent hook\n */\nexport interface UseIntentResult {\n  /**\n   * Trigger the intent with parameters\n   */\n  trigger: (params?: any) => void;\n\n  /**\n   * Whether intent is being triggered\n   */\n  triggering: boolean;\n\n  /**\n   * Last triggered params\n   */\n  lastParams: any | null;\n\n  /**\n   * History of triggered intents\n   */\n  history: IntentHistoryEntry[];\n\n  /**\n   * Clear trigger history\n   */\n  clearHistory: () => void;\n\n  /**\n   * Error from last trigger\n   */\n  error: Error | null;\n}\n\n/**\n * Hook for triggering application intents\n *\n * @param intentName - Name of the intent (e.g., 'navigate', 'open_file')\n * @param options - Hook configuration options\n * @returns Intent trigger state and methods\n *\n * @example\n * ```tsx\n * // Basic usage\n * const navigate = useIntent('navigate');\n * navigate.trigger({ page: 'home' });\n *\n * // With callbacks\n * const openFile = useIntent('open_file', {\n *   onTrigger: (params) => console.log('Opening:', params.path),\n *   onError: (err) => console.error('Failed:', err)\n * });\n *\n * // With debouncing\n * const search = useIntent('search', {\n *   debounce: 300 // Debounce rapid searches\n * });\n *\n * // With history tracking\n * const actions = useIntent('user_action', {\n *   trackHistory: true\n * });\n * console.log('Recent actions:', actions.history);\n * ```\n */\nexport function useIntent(\n  intentName: string,\n  options: UseIntentOptions = {}\n): UseIntentResult {\n  const {\n    onTrigger,\n    onError,\n    trackHistory = true,\n    maxHistorySize = 50,\n    debounce = 0,\n  } = options;\n\n  const [triggering, setTriggering] = useState(false);\n  const [lastParams, setLastParams] = useState<any | null>(null);\n  const [history, setHistory] = useState<IntentHistoryEntry[]>([]);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Ref to track if component is mounted\n  const isMountedRef = useRef(true);\n\n  // Ref for debounce timeout\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n      if (debounceTimeoutRef.current) {\n        clearTimeout(debounceTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  /**\n   * Internal trigger function\n   */\n  const internalTrigger = useCallback(\n    (params: any = {}) => {\n      try {\n        // Validate intent name\n        if (typeof intentName !== 'string' || !intentName.trim()) {\n          throw new Error('Intent name must be a non-empty string');\n        }\n\n        // Check if window.triggerIntent exists\n        if (typeof window === 'undefined' || !window.triggerIntent) {\n          throw new Error(\n            'window.triggerIntent is not available. Are you running in an MCP UI context?'\n          );\n        }\n\n        // Mark as triggering\n        setTriggering(true);\n        setError(null);\n\n        // Trigger intent\n        window.triggerIntent(intentName, params);\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setLastParams(params);\n          setTriggering(false);\n\n          // Track in history\n          if (trackHistory) {\n            setHistory((prev) => {\n              const entry: IntentHistoryEntry = {\n                intent: intentName,\n                params,\n                timestamp: Date.now(),\n              };\n              const newHistory = [entry, ...prev];\n              // Limit history size\n              return newHistory.slice(0, maxHistorySize);\n            });\n          }\n\n          // Call success callback\n          if (onTrigger) {\n            onTrigger(params);\n          }\n        }\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setError(error);\n          setTriggering(false);\n\n          // Call error callback\n          if (onError) {\n            onError(error, intentName, params);\n          }\n        }\n      }\n    },\n    [intentName, trackHistory, maxHistorySize, onTrigger, onError]\n  );\n\n  /**\n   * Trigger with optional debouncing\n   */\n  const trigger = useCallback(\n    (params: any = {}) => {\n      if (debounce > 0) {\n        // Clear existing timeout\n        if (debounceTimeoutRef.current) {\n          clearTimeout(debounceTimeoutRef.current);\n        }\n\n        // Set new timeout\n        debounceTimeoutRef.current = setTimeout(() => {\n          internalTrigger(params);\n        }, debounce);\n      } else {\n        // No debounce - trigger immediately\n        internalTrigger(params);\n      }\n    },\n    [debounce, internalTrigger]\n  );\n\n  /**\n   * Clear history\n   */\n  const clearHistory = useCallback(() => {\n    setHistory([]);\n  }, []);\n\n  return {\n    trigger,\n    triggering,\n    lastParams,\n    history,\n    clearHistory,\n    error,\n  };\n}\n", "/**\n * useNotify Hook - Send Notifications\n *\n * Hook for sending notifications from MCP UI components to the parent application.\n * Provides state tracking, notification queue, and callback support.\n *\n * @example\n * ```tsx\n * import { useNotify } from 'simply-mcp/client';\n * import { Button } from '@/components/ui/button';\n *\n * function SaveButton() {\n *   const notify = useNotify();\n *\n *   const handleSave = async () => {\n *     try {\n *       await saveData();\n *       notify.success('Data saved successfully!');\n *     } catch (error) {\n *       notify.error('Failed to save data');\n *     }\n *   };\n *\n *   return <Button onClick={handleSave}>Save</Button>;\n * }\n * ```\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n/**\n * Notification level\n */\nexport type NotificationLevel = 'info' | 'success' | 'warning' | 'error';\n\n/**\n * Options for useNotify hook\n */\nexport interface UseNotifyOptions {\n  /**\n   * Called when notification is sent\n   */\n  onNotify?: (level: NotificationLevel, message: string) => void;\n\n  /**\n   * Called when notification fails\n   */\n  onError?: (error: Error, level: NotificationLevel, message: string) => void;\n\n  /**\n   * Track notification history\n   * @default true\n   */\n  trackHistory?: boolean;\n\n  /**\n   * Maximum history size\n   * @default 100\n   */\n  maxHistorySize?: number;\n\n  /**\n   * Rate limit (max notifications per second)\n   * @default 0 (no limit)\n   */\n  rateLimit?: number;\n}\n\n/**\n * Notification history entry\n */\nexport interface NotificationHistoryEntry {\n  level: NotificationLevel;\n  message: string;\n  timestamp: number;\n}\n\n/**\n * Return value from useNotify hook\n */\nexport interface UseNotifyResult {\n  /**\n   * Send a notification\n   */\n  notify: (level: NotificationLevel, message: string) => void;\n\n  /**\n   * Send an info notification\n   */\n  info: (message: string) => void;\n\n  /**\n   * Send a success notification\n   */\n  success: (message: string) => void;\n\n  /**\n   * Send a warning notification\n   */\n  warning: (message: string) => void;\n\n  /**\n   * Send an error notification\n   */\n  error: (message: string) => void;\n\n  /**\n   * History of sent notifications\n   */\n  history: NotificationHistoryEntry[];\n\n  /**\n   * Clear notification history\n   */\n  clearHistory: () => void;\n\n  /**\n   * Last notification sent\n   */\n  lastNotification: NotificationHistoryEntry | null;\n\n  /**\n   * Error from last notification\n   */\n  notifyError: Error | null;\n}\n\n/**\n * Hook for sending notifications\n *\n * @param options - Hook configuration options\n * @returns Notification methods and state\n *\n * @example\n * ```tsx\n * // Basic usage\n * const notify = useNotify();\n * notify.success('Operation completed!');\n * notify.error('Something went wrong');\n *\n * // With callbacks\n * const notify = useNotify({\n *   onNotify: (level, msg) => console.log(`[${level}] ${msg}`),\n *   onError: (err) => console.error('Notification failed:', err)\n * });\n *\n * // With history tracking\n * const notify = useNotify({\n *   trackHistory: true,\n *   maxHistorySize: 50\n * });\n * console.log('Recent notifications:', notify.history);\n *\n * // With rate limiting\n * const notify = useNotify({\n *   rateLimit: 5 // Max 5 notifications per second\n * });\n * ```\n */\nexport function useNotify(options: UseNotifyOptions = {}): UseNotifyResult {\n  const {\n    onNotify,\n    onError,\n    trackHistory = true,\n    maxHistorySize = 100,\n    rateLimit = 0,\n  } = options;\n\n  const [history, setHistory] = useState<NotificationHistoryEntry[]>([]);\n  const [lastNotification, setLastNotification] = useState<NotificationHistoryEntry | null>(null);\n  const [notifyError, setNotifyError] = useState<Error | null>(null);\n\n  // Ref to track if component is mounted\n  const isMountedRef = useRef(true);\n\n  // Ref for rate limiting\n  const notificationTimesRef = useRef<number[]>([]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * Check rate limit\n   */\n  const checkRateLimit = useCallback((): boolean => {\n    if (rateLimit === 0) return true;\n\n    const now = Date.now();\n    const oneSecondAgo = now - 1000;\n\n    // Remove old timestamps\n    notificationTimesRef.current = notificationTimesRef.current.filter(\n      (time) => time > oneSecondAgo\n    );\n\n    // Check if we're at the limit\n    if (notificationTimesRef.current.length >= rateLimit) {\n      return false;\n    }\n\n    // Add current timestamp\n    notificationTimesRef.current.push(now);\n    return true;\n  }, [rateLimit]);\n\n  /**\n   * Send a notification\n   */\n  const notify = useCallback(\n    (level: NotificationLevel, message: string) => {\n      try {\n        // Validate inputs\n        if (typeof message !== 'string' || !message.trim()) {\n          throw new Error('Message must be a non-empty string');\n        }\n\n        const validLevels: NotificationLevel[] = ['info', 'success', 'warning', 'error'];\n        if (!validLevels.includes(level)) {\n          throw new Error(`Invalid notification level: ${level}`);\n        }\n\n        // Check rate limit\n        if (!checkRateLimit()) {\n          console.warn('Notification rate limit exceeded');\n          return;\n        }\n\n        // Check if window.notify exists\n        if (typeof window === 'undefined' || !window.notify) {\n          throw new Error(\n            'window.notify is not available. Are you running in an MCP UI context?'\n          );\n        }\n\n        const trimmedMessage = message.trim();\n\n        // Send notification\n        window.notify(level, trimmedMessage);\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          const entry: NotificationHistoryEntry = {\n            level,\n            message: trimmedMessage,\n            timestamp: Date.now(),\n          };\n\n          setLastNotification(entry);\n          setNotifyError(null);\n\n          // Track in history\n          if (trackHistory) {\n            setHistory((prev) => {\n              const newHistory = [entry, ...prev];\n              // Limit history size\n              return newHistory.slice(0, maxHistorySize);\n            });\n          }\n\n          // Call success callback\n          if (onNotify) {\n            onNotify(level, trimmedMessage);\n          }\n        }\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setNotifyError(error);\n\n          // Call error callback\n          if (onError) {\n            onError(error, level, message);\n          }\n        }\n      }\n    },\n    [trackHistory, maxHistorySize, onNotify, onError, checkRateLimit]\n  );\n\n  /**\n   * Convenience methods\n   */\n  const info = useCallback((message: string) => notify('info', message), [notify]);\n  const success = useCallback((message: string) => notify('success', message), [notify]);\n  const warning = useCallback((message: string) => notify('warning', message), [notify]);\n  const error = useCallback((message: string) => notify('error', message), [notify]);\n\n  /**\n   * Clear history\n   */\n  const clearHistory = useCallback(() => {\n    setHistory([]);\n  }, []);\n\n  return {\n    notify,\n    info,\n    success,\n    warning,\n    error,\n    history,\n    clearHistory,\n    lastNotification,\n    notifyError,\n  };\n}\n", "/**\n * useOpenLink Hook - Open URLs/Links\n *\n * Hook for opening URLs from MCP UI components. Provides URL validation,\n * state tracking, and callback support.\n *\n * @example\n * ```tsx\n * import { useOpenLink } from 'simply-mcp/client';\n * import { Button } from '@/components/ui/button';\n *\n * function ExternalLink() {\n *   const openLink = useOpenLink({\n *     onOpen: (url) => console.log('Opening:', url)\n *   });\n *\n *   return (\n *     <Button onClick={() => openLink.open('https://example.com')}>\n *       Visit Website\n *     </Button>\n *   );\n * }\n * ```\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n/**\n * Options for useOpenLink hook\n */\nexport interface UseOpenLinkOptions {\n  /**\n   * Called when link is opened\n   */\n  onOpen?: (url: string) => void;\n\n  /**\n   * Called when link opening fails\n   */\n  onError?: (error: Error, url: string) => void;\n\n  /**\n   * Validate URLs before opening\n   * @default true\n   */\n  validateUrl?: boolean;\n\n  /**\n   * Allow only HTTPS URLs\n   * @default false\n   */\n  httpsOnly?: boolean;\n\n  /**\n   * Track link opening history\n   * @default true\n   */\n  trackHistory?: boolean;\n\n  /**\n   * Maximum history size\n   * @default 50\n   */\n  maxHistorySize?: number;\n\n  /**\n   * Allowed domains (empty = all allowed)\n   * @default []\n   */\n  allowedDomains?: string[];\n}\n\n/**\n * Link history entry\n */\nexport interface LinkHistoryEntry {\n  url: string;\n  timestamp: number;\n}\n\n/**\n * Return value from useOpenLink hook\n */\nexport interface UseOpenLinkResult {\n  /**\n   * Open a URL\n   */\n  open: (url: string) => void;\n\n  /**\n   * Whether a link is being opened\n   */\n  opening: boolean;\n\n  /**\n   * Last opened URL\n   */\n  lastUrl: string | null;\n\n  /**\n   * History of opened links\n   */\n  history: LinkHistoryEntry[];\n\n  /**\n   * Clear link history\n   */\n  clearHistory: () => void;\n\n  /**\n   * Error from last open attempt\n   */\n  error: Error | null;\n}\n\n/**\n * Validate URL format\n */\nfunction isValidUrl(urlString: string): boolean {\n  try {\n    new URL(urlString);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extract domain from URL\n */\nfunction extractDomain(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.hostname;\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Hook for opening URLs/links\n *\n * @param options - Hook configuration options\n * @returns Link opening methods and state\n *\n * @example\n * ```tsx\n * // Basic usage\n * const link = useOpenLink();\n * link.open('https://example.com');\n *\n * // With validation\n * const link = useOpenLink({\n *   validateUrl: true,\n *   httpsOnly: true\n * });\n *\n * // With domain whitelist\n * const link = useOpenLink({\n *   allowedDomains: ['example.com', 'trusted-site.com']\n * });\n *\n * // With callbacks\n * const link = useOpenLink({\n *   onOpen: (url) => console.log('Opened:', url),\n *   onError: (err) => console.error('Failed:', err)\n * });\n *\n * // With history tracking\n * const link = useOpenLink({\n *   trackHistory: true\n * });\n * console.log('Recently opened:', link.history);\n * ```\n */\nexport function useOpenLink(options: UseOpenLinkOptions = {}): UseOpenLinkResult {\n  const {\n    onOpen,\n    onError,\n    validateUrl = true,\n    httpsOnly = false,\n    trackHistory = true,\n    maxHistorySize = 50,\n    allowedDomains = [],\n  } = options;\n\n  const [opening, setOpening] = useState(false);\n  const [lastUrl, setLastUrl] = useState<string | null>(null);\n  const [history, setHistory] = useState<LinkHistoryEntry[]>([]);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Ref to track if component is mounted\n  const isMountedRef = useRef(true);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * Open a URL\n   */\n  const open = useCallback(\n    (url: string) => {\n      try {\n        // Validate input\n        if (typeof url !== 'string' || !url.trim()) {\n          throw new Error('URL must be a non-empty string');\n        }\n\n        const trimmedUrl = url.trim();\n\n        // Validate URL format\n        if (validateUrl && !isValidUrl(trimmedUrl)) {\n          throw new Error(`Invalid URL format: ${trimmedUrl}`);\n        }\n\n        // Check HTTPS requirement\n        if (httpsOnly && !trimmedUrl.startsWith('https://')) {\n          throw new Error(`Only HTTPS URLs are allowed: ${trimmedUrl}`);\n        }\n\n        // Check domain whitelist\n        if (allowedDomains.length > 0) {\n          const domain = extractDomain(trimmedUrl);\n          if (!allowedDomains.includes(domain)) {\n            throw new Error(\n              `Domain not allowed: ${domain}. Allowed domains: ${allowedDomains.join(', ')}`\n            );\n          }\n        }\n\n        // Check if window.openLink exists\n        if (typeof window === 'undefined' || !window.openLink) {\n          throw new Error(\n            'window.openLink is not available. Are you running in an MCP UI context?'\n          );\n        }\n\n        // Mark as opening\n        setOpening(true);\n        setError(null);\n\n        // Open link\n        window.openLink(trimmedUrl);\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setLastUrl(trimmedUrl);\n          setOpening(false);\n\n          // Track in history\n          if (trackHistory) {\n            setHistory((prev) => {\n              const entry: LinkHistoryEntry = {\n                url: trimmedUrl,\n                timestamp: Date.now(),\n              };\n              const newHistory = [entry, ...prev];\n              // Limit history size\n              return newHistory.slice(0, maxHistorySize);\n            });\n          }\n\n          // Call success callback\n          if (onOpen) {\n            onOpen(trimmedUrl);\n          }\n        }\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Update state only if still mounted\n        if (isMountedRef.current) {\n          setError(error);\n          setOpening(false);\n\n          // Call error callback\n          if (onError) {\n            onError(error, url);\n          }\n        }\n      }\n    },\n    [\n      validateUrl,\n      httpsOnly,\n      allowedDomains,\n      trackHistory,\n      maxHistorySize,\n      onOpen,\n      onError,\n    ]\n  );\n\n  /**\n   * Clear history\n   */\n  const clearHistory = useCallback(() => {\n    setHistory([]);\n  }, []);\n\n  return {\n    open,\n    opening,\n    lastUrl,\n    history,\n    clearHistory,\n    error,\n  };\n}\n"],
  "mappings": "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",
  "names": ["error", "useState", "useCallback", "useRef", "useEffect", "error", "useState", "useCallback", "useRef", "useEffect", "error", "useState", "useCallback", "useRef", "useEffect", "error", "useState", "useCallback", "useRef", "useEffect", "error"]
}
