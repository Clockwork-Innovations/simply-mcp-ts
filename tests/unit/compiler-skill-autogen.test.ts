/**
 * Unit Tests: Skill Compiler Auto-Generation
 *
 * Tests compiler validation of FT-2 auto-generation features:
 * - Mutual exclusivity (returns XOR components)
 * - Component extraction from interface
 * - Validation of component structure
 */

import * as ts from 'typescript';
import { compileSkillInterface } from '../../src/server/compiler/compilers/skill-compiler.js';

/**
 * Helper function to compile TypeScript code and extract skill interface
 */
function compileInterfaceCode(code: string): {
  result: any;
  errors: string[];
} {
  const sourceFile = ts.createSourceFile(
    'test.ts',
    code,
    ts.ScriptTarget.Latest,
    true
  );

  const errors: string[] = [];
  let result: any = null;

  ts.forEachChild(sourceFile, (node) => {
    if (ts.isInterfaceDeclaration(node) && node.name.text.includes('Skill')) {
      result = compileSkillInterface(node, sourceFile, errors);
    }
  });

  return { result, errors };
}

describe('Skill Compiler - Auto-Generation Validation', () => {
  describe('Mutual exclusivity enforcement', () => {
    it('should compile skill with returns only (manual)', () => {
      const code = `
        interface TestSkill extends ISkill {
          name: 'test';
          description: 'Test skill';
          skill: string;
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result).not.toBeNull();
      expect(result?.name).toBe('test');
      expect(result?.isAutoGenerated).toBe(false);
      expect(result?.components).toBeUndefined();
    });

    it('should compile skill with components only (auto-gen)', () => {
      const code = `
        interface TestSkill extends ISkill {
          name: 'test';
          description: 'Test skill';
          tools: ['tool1', 'tool2'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result).not.toBeNull();
      expect(result?.name).toBe('test');
      expect(result?.isAutoGenerated).toBe(true);
      expect(result?.tools).toEqual(['tool1', 'tool2']);
    });

    it('should ERROR when skill has both returns and components', () => {
      const code = `
        interface BadSkill extends ISkill {
          name: 'bad';
          description: 'Bad skill';
          skill: string;
          tools: ['tool1'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(1);
      expect(errors[0]).toContain('both manual content and auto-generation');
      expect(errors[0]).toContain('mutually exclusive');
      expect(errors[0]).toContain('Remove either');
      expect(result).toBeNull();
    });

    it('should ERROR when skill has neither returns nor components', () => {
      const code = `
        interface BadSkill extends ISkill {
          name: 'bad';
          description: 'Bad skill';
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(1);
      expect(errors[0]).toContain('must have either manual content or auto-generation');
      expect(errors[0]).toContain('skill: string');
      expect(result).toBeNull();
    });
  });

  describe('Component extraction from interface', () => {
    it('should extract tools array from components', () => {
      const code = `
        interface TestSkill extends ISkill {
          name: 'test';
          description: 'Test';
          tools: ['get_weather', 'get_forecast'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.tools).toEqual(['get_weather', 'get_forecast']);
      expect(result?.isAutoGenerated).toBe(true);
    });

    it('should extract resources array from components', () => {
      const code = `
        interface TestSkill extends ISkill {
          name: 'test';
          description: 'Test';
          resources: ['config://api', 'data://cache'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.resources).toEqual(['config://api', 'data://cache']);
    });

    it('should extract prompts array from components', () => {
      const code = `
        interface TestSkill extends ISkill {
          name: 'test';
          description: 'Test';
          prompts: ['help', 'tutorial'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.prompts).toEqual(['help', 'tutorial']);
    });

    it('should extract all component types together', () => {
      const code = `
        interface CompleteSkill extends ISkill {
          name: 'complete';
          description: 'Complete';
          tools: ['tool1', 'tool2'];
          resources: ['res1'];
          prompts: ['prompt1', 'prompt2', 'prompt3'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.tools).toEqual(['tool1', 'tool2']);
      expect(result?.resources).toEqual(['res1']);
      expect(result?.prompts).toEqual(['prompt1', 'prompt2', 'prompt3']);
    });

    it('should handle components with only some fields defined', () => {
      const code = `
        interface PartialSkill extends ISkill {
          name: 'partial';
          description: 'Partial';
          tools: ['tool1'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.tools).toEqual(['tool1']);
      expect(result?.resources).toBeUndefined();
      expect(result?.prompts).toBeUndefined();
    });
  });

  describe('Empty component arrays', () => {
    it('should handle empty tools array', () => {
      const code = `
        interface EmptySkill extends ISkill {
          name: 'empty';
          description: 'Empty';
          tools: [];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      // Empty arrays are technically valid but result in no components extracted
      expect(errors).toHaveLength(0);
      // parseStringArray returns undefined for empty tuple arrays
      expect(result?.tools).toBeUndefined();
    });

    it('should handle components with no arrays defined', () => {
      const code = `
        interface NoArraysSkill extends ISkill {
          name: 'noarrays';
          description: 'No arrays';
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(1);
      // No components means error - must have either skill or components
      expect(errors[0]).toContain('must have either manual content or auto-generation');
    });
  });

  describe('isAutoGenerated flag', () => {
    it('should set isAutoGenerated to true when components present', () => {
      const code = `
        interface AutoGenSkill extends ISkill {
          name: 'autogen';
          description: 'Auto-generated';
          tools: ['tool1'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.isAutoGenerated).toBe(true);
    });

    it('should set isAutoGenerated to false when returns present', () => {
      const code = `
        interface ManualSkill extends ISkill {
          name: 'manual';
          description: 'Manual';
          skill: string;
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.isAutoGenerated).toBe(false);
    });
  });

  describe('Component validation with other fields', () => {
    it('should compile auto-gen skill with hidden flag', () => {
      const code = `
        interface HiddenAutoGenSkill extends ISkill {
          name: 'hidden_autogen';
          description: 'Hidden auto-gen';
          tools: ['secret_tool'];
          hidden: true;
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.isAutoGenerated).toBe(true);
      expect(result?.hidden).toBe(true);
      expect(result?.tools).toEqual(['secret_tool']);
    });

    it('should validate name format even with components', () => {
      const code = `
        interface BadNameSkill extends ISkill {
          name: 'BadName';
          description: 'Bad name';
          tools: ['tool1'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(1);
      expect(errors[0]).toContain('invalid name format');
      expect(errors[0]).toContain('snake_case');
      expect(result).toBeNull();
    });

    it('should require description even with components', () => {
      const code = `
        interface NoDescSkill extends ISkill {
          name: 'nodesc';
          tools: ['tool1'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(1);
      expect(errors[0]).toContain('missing required \'description\' field');
      expect(result).toBeNull();
    });
  });

  describe('Complex component scenarios', () => {
    it('should handle URIs with templates in resources', () => {
      const code = `
        interface TemplateSkill extends ISkill {
          name: 'template';
          description: 'Template';
          resources: ['data://users/{id}', 'config://settings/{key}'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.resources).toEqual([
        'data://users/{id}',
        'config://settings/{key}',
      ]);
    });

    it('should handle mixed component references', () => {
      const code = `
        interface MixedSkill extends ISkill {
          name: 'mixed';
          description: 'Mixed';
          tools: ['public_tool', '_private_tool'];
          resources: ['config://public', 'internal://private'];
          prompts: ['help', 'advanced_help'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.tools).toEqual(['public_tool', '_private_tool']);
      expect(result?.resources).toEqual(['config://public', 'internal://private']);
      expect(result?.prompts).toEqual(['help', 'advanced_help']);
    });
  });

  describe('Error message quality', () => {
    it('should provide clear error for mutual exclusivity violation', () => {
      const code = `
        interface BadSkill extends ISkill {
          name: 'bad';
          description: 'Bad';
          skill: string;
          tools: ['t1'];
        }
      `;

      const { errors } = compileInterfaceCode(code);

      expect(errors[0]).toContain('mutually exclusive');
      expect(errors[0]).toContain('use one OR the other');
      expect(errors[0]).toContain('Manual:');
      expect(errors[0]).toContain('Auto-gen:');
      expect(errors[0]).toContain('To fix:');
    });

    it('should provide clear error for missing both fields', () => {
      const code = `
        interface BadSkill extends ISkill {
          name: 'bad';
          description: 'Bad';
        }
      `;

      const { errors } = compileInterfaceCode(code);

      expect(errors[0]).toContain('must have either');
      expect(errors[0]).toContain('skill: string');
      expect(errors[0]).toContain('tools:');
      expect(errors[0]).toContain('Example:');
    });
  });

  describe('Method name derivation', () => {
    it('should derive correct method name for auto-gen skill', () => {
      const code = `
        interface WeatherApiSkill extends ISkill {
          name: 'weather_api';
          description: 'Weather API';
          tools: ['get_weather'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.methodName).toBe('weatherApi');
    });

    it('should derive correct method name with underscores', () => {
      const code = `
        interface ComplexNameSkill extends ISkill {
          name: 'complex_skill_name_test';
          description: 'Complex';
          tools: ['tool1'];
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.methodName).toBe('complexSkillNameTest');
    });
  });

  describe('Backward compatibility', () => {
    it('should still compile traditional manual skills', () => {
      const code = `
        interface TraditionalSkill extends ISkill {
          name: 'traditional';
          description: 'Traditional skill';
          skill: string;
        }
      `;

      const { result, errors } = compileInterfaceCode(code);

      expect(errors).toHaveLength(0);
      expect(result?.name).toBe('traditional');
      expect(result?.isAutoGenerated).toBe(false);
      expect(result?.tools).toBeUndefined();
      expect(result?.resources).toBeUndefined();
      expect(result?.prompts).toBeUndefined();
      expect(result?.returnsType).toBe('string');
    });
  });
});
