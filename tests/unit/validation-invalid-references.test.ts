/**
 * Unit Tests: Invalid Component References Rule
 *
 * Tests the validation rule that detects skills referencing non-existent
 * tools, resources, or prompts.
 */

import { describe, it, expect } from '@jest/globals';
import { checkInvalidReferences } from '../../src/server/compiler/validators/rules/invalid-references.js';
import type { ValidationContext } from '../../src/server/compiler/validators/types.js';
import type { ParsedTool, ParsedResource, ParsedPrompt, ParsedSkill } from '../../src/server/compiler/types.js';

/**
 * Helper to create a minimal validation context for testing
 */
function createTestContext(overrides?: Partial<ValidationContext>): ValidationContext {
  return {
    tools: new Map<string, ParsedTool>(),
    resources: new Map<string, ParsedResource>(),
    prompts: new Map<string, ParsedPrompt>(),
    skills: new Map<string, ParsedSkill>(),
    sourceFile: '/test/server.ts',
    config: {
      enabled: true,
      rules: {
        orphanedHidden: 'warn',
        invalidReferences: 'error',
        nonHiddenComponents: 'warn',
        emptySkills: 'warn'
      },
      strict: false
    },
    ...overrides
  };
}

describe('Invalid Component References Rule', () => {
  describe('Invalid Tool References', () => {
    it('should error when skill references non-existent tool', () => {
      const context = createTestContext({
        tools: new Map([
          ['existing_tool', {
            name: 'existing_tool',
            methodName: 'existingTool'
          } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            description: 'Test skill',
            isAutoGenerated: true,
            tools: ['nonexistent_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('invalid-tool-reference');
      expect(warnings[0].severity).toBe('error');
      expect(warnings[0].message).toContain('test_skill');
      expect(warnings[0].message).toContain('nonexistent_tool');
      expect(warnings[0].message).toContain("doesn't exist");
      expect(warnings[0].suggestion).toContain('existing_tool');
      expect(warnings[0].relatedItems).toContain('existing_tool');
    });

    it('should not warn when skill references existing tool', () => {
      const context = createTestContext({
        tools: new Map([
          ['greet', {
            name: 'greet',
            methodName: 'greet'
          } as ParsedTool]
        ]),
        skills: new Map([
          ['greeting_skill', {
            name: 'greeting_skill',
            isAutoGenerated: true,
            tools: ['greet']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });

    it('should list all available tools when tool not found', () => {
      const context = createTestContext({
        tools: new Map([
          ['tool1', { name: 'tool1' } as ParsedTool],
          ['tool2', { name: 'tool2' } as ParsedTool],
          ['tool3', { name: 'tool3' } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['wrong_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].suggestion).toContain('tool1');
      expect(warnings[0].suggestion).toContain('tool2');
      expect(warnings[0].suggestion).toContain('tool3');
      expect(warnings[0].relatedItems).toEqual(['tool1', 'tool2', 'tool3']);
    });

    it('should handle skill referencing multiple invalid tools', () => {
      const context = createTestContext({
        tools: new Map([
          ['valid_tool', { name: 'valid_tool' } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['invalid1', 'invalid2', 'valid_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(2);
      expect(warnings.find(w => w.message.includes('invalid1'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('invalid2'))).toBeDefined();
    });

    it('should provide helpful message when no tools exist', () => {
      const context = createTestContext({
        tools: new Map(),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['some_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].suggestion).toContain('No tools are defined');
    });
  });

  describe('Invalid Resource References', () => {
    it('should error when skill references non-existent resource', () => {
      const context = createTestContext({
        resources: new Map([
          ['file://existing', {
            uri: 'file://existing',
            name: 'Existing'
          } as ParsedResource]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            resources: ['file://nonexistent']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('invalid-resource-reference');
      expect(warnings[0].message).toContain('file://nonexistent');
      expect(warnings[0].suggestion).toContain('file://existing');
    });

    it('should not warn when skill references existing resource', () => {
      const context = createTestContext({
        resources: new Map([
          ['config://server', {
            uri: 'config://server',
            name: 'Server Config'
          } as ParsedResource]
        ]),
        skills: new Map([
          ['config_skill', {
            name: 'config_skill',
            isAutoGenerated: true,
            resources: ['config://server']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });

    it('should provide helpful message when no resources exist', () => {
      const context = createTestContext({
        resources: new Map(),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            resources: ['file://something']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].suggestion).toContain('No resources are defined');
    });
  });

  describe('Invalid Prompt References', () => {
    it('should error when skill references non-existent prompt', () => {
      const context = createTestContext({
        prompts: new Map([
          ['existing_prompt', {
            name: 'existing_prompt',
            description: 'Existing'
          } as ParsedPrompt]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            prompts: ['nonexistent_prompt']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('invalid-prompt-reference');
      expect(warnings[0].message).toContain('nonexistent_prompt');
      expect(warnings[0].suggestion).toContain('existing_prompt');
    });

    it('should not warn when skill references existing prompt', () => {
      const context = createTestContext({
        prompts: new Map([
          ['code_review', {
            name: 'code_review',
            description: 'Code Review'
          } as ParsedPrompt]
        ]),
        skills: new Map([
          ['review_skill', {
            name: 'review_skill',
            isAutoGenerated: true,
            prompts: ['code_review']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });

    it('should provide helpful message when no prompts exist', () => {
      const context = createTestContext({
        prompts: new Map(),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            prompts: ['some_prompt']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].suggestion).toContain('No prompts are defined');
    });
  });

  describe('Mixed Component Types', () => {
    it('should detect invalid references across all component types', () => {
      const context = createTestContext({
        tools: new Map([['valid_tool', { name: 'valid_tool' } as ParsedTool]]),
        resources: new Map([['file://valid', { uri: 'file://valid' } as ParsedResource]]),
        prompts: new Map([['valid_prompt', { name: 'valid_prompt' } as ParsedPrompt]]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['invalid_tool'],
            resources: ['file://invalid'],
            prompts: ['invalid_prompt']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(3);
      expect(warnings.find(w => w.rule === 'invalid-tool-reference')).toBeDefined();
      expect(warnings.find(w => w.rule === 'invalid-resource-reference')).toBeDefined();
      expect(warnings.find(w => w.rule === 'invalid-prompt-reference')).toBeDefined();
    });

    it('should only warn about invalid references, not valid ones', () => {
      const context = createTestContext({
        tools: new Map([
          ['tool1', { name: 'tool1' } as ParsedTool],
          ['tool2', { name: 'tool2' } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['tool1', 'invalid_tool', 'tool2']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].message).toContain('invalid_tool');
      expect(warnings[0].message).not.toContain('tool1');
      expect(warnings[0].message).not.toContain('tool2');
    });
  });

  describe('Multiple Skills', () => {
    it('should detect invalid references across multiple skills', () => {
      const context = createTestContext({
        tools: new Map([['valid_tool', { name: 'valid_tool' } as ParsedTool]]),
        skills: new Map([
          ['skill1', {
            name: 'skill1',
            isAutoGenerated: true,
            tools: ['invalid1']
          } as ParsedSkill],
          ['skill2', {
            name: 'skill2',
            isAutoGenerated: true,
            tools: ['invalid2']
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(2);
      expect(warnings.find(w => w.message.includes('skill1'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('skill2'))).toBeDefined();
    });
  });

  describe('Configuration', () => {
    it('should respect "off" config', () => {
      const context = createTestContext({
        tools: new Map([['valid', { name: 'valid' } as ParsedTool]]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['invalid']
          } as ParsedSkill]
        ]),
        config: {
          enabled: true,
          rules: {
            invalidReferences: 'off'
          }
        }
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });

    it('should use "error" severity when configured', () => {
      const context = createTestContext({
        tools: new Map(),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['invalid']
          } as ParsedSkill]
        ]),
        config: {
          enabled: true,
          rules: {
            invalidReferences: 'error'
          }
        }
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].severity).toBe('error');
    });

    it('should use "warning" severity when configured as "warn"', () => {
      const context = createTestContext({
        tools: new Map(),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['invalid']
          } as ParsedSkill]
        ]),
        config: {
          enabled: true,
          rules: {
            invalidReferences: 'warn'
          }
        }
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].severity).toBe('warning');
    });
  });

  describe('Edge Cases', () => {
    it('should handle skills without components field', () => {
      const context = createTestContext({
        tools: new Map([['tool1', { name: 'tool1' } as ParsedTool]]),
        skills: new Map([
          ['manual_skill', {
            name: 'manual_skill',
            description: 'Manual skill',
            skill: 'string'
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle skills with empty components arrays', () => {
      const context = createTestContext({
        tools: new Map([['tool1', { name: 'tool1' } as ParsedTool]]),
        skills: new Map([
          ['empty_skill', {
            name: 'empty_skill',
            tools: [],
            resources: [],
            prompts: []
          } as ParsedSkill]
        ])
      });

      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle empty context', () => {
      const context = createTestContext();
      const warnings = checkInvalidReferences(context);

      expect(warnings).toHaveLength(0);
    });
  });
});
