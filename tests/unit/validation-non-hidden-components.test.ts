/**
 * Unit Tests: Non-Hidden Components Rule
 *
 * Tests the validation rule that detects skills referencing public
 * (non-hidden) components, which is typically a design smell.
 */

import { describe, it, expect } from '@jest/globals';
import { checkNonHiddenComponents } from '../../src/server/compiler/validators/rules/non-hidden-components.js';
import type { ValidationContext } from '../../src/server/compiler/validators/types.js';
import type { ParsedTool, ParsedResource, ParsedPrompt, ParsedSkill } from '../../src/server/compiler/types.js';

/**
 * Helper to create a minimal validation context for testing
 */
function createTestContext(overrides?: Partial<ValidationContext>): ValidationContext {
  return {
    tools: new Map<string, ParsedTool>(),
    resources: new Map<string, ParsedResource>(),
    prompts: new Map<string, ParsedPrompt>(),
    skills: new Map<string, ParsedSkill>(),
    sourceFile: '/test/server.ts',
    config: {
      enabled: true,
      rules: {
        orphanedHidden: 'warn',
        invalidReferences: 'error',
        nonHiddenComponents: 'warn',
        emptySkills: 'warn'
      },
      strict: false
    },
    ...overrides
  };
}

describe('Non-Hidden Components Rule', () => {
  describe('Non-Hidden Tools', () => {
    it('should warn when skill references visible (non-hidden) tool', () => {
      const context = createTestContext({
        tools: new Map([
          ['greet', {
            name: 'greet',
            methodName: 'greet',
            description: 'Greet a user',
            hidden: false
          } as ParsedTool]
        ]),
        skills: new Map([
          ['greeting_skill', {
            name: 'greeting_skill',
            description: 'Greeting operations',
            isAutoGenerated: true,
            tools: ['greet']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('non-hidden-component');
      expect(warnings[0].severity).toBe('warning');
      expect(warnings[0].message).toContain('greeting_skill');
      expect(warnings[0].message).toContain('greet');
      expect(warnings[0].message).toContain('not hidden');
      expect(warnings[0].suggestion).toContain('Mark the tool as hidden');
      expect(warnings[0].suggestion).toContain('Remove the tool from skill component arrays');
      expect(warnings[0].suggestion).toContain('Disable this warning');
    });

    it('should not warn when skill references hidden tool', () => {
      const context = createTestContext({
        tools: new Map([
          ['debug_tool', {
            name: 'debug_tool',
            hidden: true
          } as ParsedTool]
        ]),
        skills: new Map([
          ['debug_skill', {
            name: 'debug_skill',
            isAutoGenerated: true,
            tools: ['debug_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle tools with no hidden field (defaults to false)', () => {
      const context = createTestContext({
        tools: new Map([
          ['public_tool', {
            name: 'public_tool'
            // No hidden field - defaults to false/visible
          } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['public_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].message).toContain('public_tool');
      expect(warnings[0].message).toContain('not hidden');
    });

    it('should warn about each non-hidden tool separately', () => {
      const context = createTestContext({
        tools: new Map([
          ['tool1', { name: 'tool1', hidden: false } as ParsedTool],
          ['tool2', { name: 'tool2', hidden: false } as ParsedTool],
          ['tool3', { name: 'tool3', hidden: true } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['tool1', 'tool2', 'tool3']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(2); // tool1 and tool2, not tool3
      expect(warnings.find(w => w.message.includes('tool1'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('tool2'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('tool3'))).toBeUndefined();
    });
  });

  describe('Non-Hidden Resources', () => {
    it('should warn when skill references visible resource', () => {
      const context = createTestContext({
        resources: new Map([
          ['file://public', {
            uri: 'file://public',
            name: 'Public File',
            hidden: false
          } as ParsedResource]
        ]),
        skills: new Map([
          ['file_skill', {
            name: 'file_skill',
            isAutoGenerated: true,
            resources: ['file://public']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('non-hidden-component');
      expect(warnings[0].message).toContain('file://public');
      expect(warnings[0].message).toContain('not hidden');
    });

    it('should not warn when skill references hidden resource', () => {
      const context = createTestContext({
        resources: new Map([
          ['config://secret', {
            uri: 'config://secret',
            hidden: true
          } as ParsedResource]
        ]),
        skills: new Map([
          ['config_skill', {
            name: 'config_skill',
            isAutoGenerated: true,
            resources: ['config://secret']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });
  });

  describe('Non-Hidden Prompts', () => {
    it('should warn when skill references visible prompt', () => {
      const context = createTestContext({
        prompts: new Map([
          ['public_prompt', {
            name: 'public_prompt',
            description: 'Public prompt',
            hidden: false
          } as ParsedPrompt]
        ]),
        skills: new Map([
          ['prompt_skill', {
            name: 'prompt_skill',
            isAutoGenerated: true,
            prompts: ['public_prompt']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].message).toContain('public_prompt');
      expect(warnings[0].message).toContain('not hidden');
    });

    it('should not warn when skill references hidden prompt', () => {
      const context = createTestContext({
        prompts: new Map([
          ['admin_prompt', {
            name: 'admin_prompt',
            hidden: true
          } as ParsedPrompt]
        ]),
        skills: new Map([
          ['admin_skill', {
            name: 'admin_skill',
            isAutoGenerated: true,
            prompts: ['admin_prompt']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });
  });

  describe('Mixed Component Types', () => {
    it('should detect non-hidden components across all types', () => {
      const context = createTestContext({
        tools: new Map([
          ['public_tool', { name: 'public_tool', hidden: false } as ParsedTool]
        ]),
        resources: new Map([
          ['file://public', { uri: 'file://public', hidden: false } as ParsedResource]
        ]),
        prompts: new Map([
          ['public_prompt', { name: 'public_prompt', hidden: false } as ParsedPrompt]
        ]),
        skills: new Map([
          ['mixed_skill', {
            name: 'mixed_skill',
            isAutoGenerated: true,
            tools: ['public_tool'],
            resources: ['file://public'],
            prompts: ['public_prompt']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(3);
      expect(warnings.filter(w => w.rule === 'non-hidden-component')).toHaveLength(3);
      expect(warnings.find(w => w.message.includes('public_tool'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('file://public'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('public_prompt'))).toBeDefined();
    });

    it('should only warn about non-hidden components, not hidden ones', () => {
      const context = createTestContext({
        tools: new Map([
          ['public_tool', { name: 'public_tool', hidden: false } as ParsedTool],
          ['hidden_tool', { name: 'hidden_tool', hidden: true } as ParsedTool]
        ]),
        skills: new Map([
          ['mixed_skill', {
            name: 'mixed_skill',
            isAutoGenerated: true,
            tools: ['public_tool', 'hidden_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].message).toContain('public_tool');
      expect(warnings[0].message).not.toContain('hidden_tool');
    });
  });

  describe('Multiple Skills', () => {
    it('should detect non-hidden components across multiple skills', () => {
      const context = createTestContext({
        tools: new Map([
          ['tool1', { name: 'tool1', hidden: false } as ParsedTool],
          ['tool2', { name: 'tool2', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['skill1', {
            name: 'skill1',
            isAutoGenerated: true,
            tools: ['tool1']
          } as ParsedSkill],
          ['skill2', {
            name: 'skill2',
            isAutoGenerated: true,
            tools: ['tool2']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(2);
      expect(warnings.find(w => w.message.includes('skill1'))).toBeDefined();
      expect(warnings.find(w => w.message.includes('skill2'))).toBeDefined();
    });

    it('should allow different skills to reference same component', () => {
      const context = createTestContext({
        tools: new Map([
          ['shared_tool', { name: 'shared_tool', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['skill1', {
            name: 'skill1',
            isAutoGenerated: true,
            tools: ['shared_tool']
          } as ParsedSkill],
          ['skill2', {
            name: 'skill2',
            isAutoGenerated: true,
            tools: ['shared_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      // Each skill gets its own warning
      expect(warnings).toHaveLength(2);
      expect(warnings.every(w => w.message.includes('shared_tool'))).toBe(true);
    });
  });

  describe('Configuration', () => {
    it('should respect "off" config', () => {
      const context = createTestContext({
        tools: new Map([
          ['public_tool', { name: 'public_tool', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['public_tool']
          } as ParsedSkill]
        ]),
        config: {
          enabled: true,
          rules: {
            nonHiddenComponents: 'off'
          }
        }
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });

    it('should use "error" severity when configured', () => {
      const context = createTestContext({
        tools: new Map([
          ['public_tool', { name: 'public_tool', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['public_tool']
          } as ParsedSkill]
        ]),
        config: {
          enabled: true,
          rules: {
            nonHiddenComponents: 'error'
          }
        }
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].severity).toBe('error');
    });

    it('should use "warning" severity when configured as "warn"', () => {
      const context = createTestContext({
        tools: new Map([
          ['public_tool', { name: 'public_tool', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['public_tool']
          } as ParsedSkill]
        ]),
        config: {
          enabled: true,
          rules: {
            nonHiddenComponents: 'warn'
          }
        }
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].severity).toBe('warning');
    });
  });

  describe('Edge Cases', () => {
    it('should handle skills without components field', () => {
      const context = createTestContext({
        tools: new Map([
          ['tool1', { name: 'tool1', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['manual_skill', {
            name: 'manual_skill',
            description: 'Manual skill',
            skill: 'string'
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle skills with empty components', () => {
      const context = createTestContext({
        tools: new Map([
          ['tool1', { name: 'tool1', hidden: false } as ParsedTool]
        ]),
        skills: new Map([
          ['empty_skill', {
            name: 'empty_skill',
            tools: [],
            resources: [],
            prompts: []
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle component that does not exist (caught by another rule)', () => {
      const context = createTestContext({
        tools: new Map(),
        skills: new Map([
          ['test_skill', {
            name: 'test_skill',
            isAutoGenerated: true,
            tools: ['nonexistent_tool']
          } as ParsedSkill]
        ])
      });

      const warnings = checkNonHiddenComponents(context);

      // This rule only checks existing components, invalid references are caught by another rule
      expect(warnings).toHaveLength(0);
    });

    it('should handle empty context', () => {
      const context = createTestContext();
      const warnings = checkNonHiddenComponents(context);

      expect(warnings).toHaveLength(0);
    });
  });
});
