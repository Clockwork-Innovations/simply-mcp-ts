/**
 * Integration Tests: Validation Pipeline
 *
 * Tests the complete validation workflow from parsing through warning output.
 * These tests use the real compiler and validator implementations.
 */

import { describe, it, expect } from '@jest/globals';
import { validateSkills } from '../../src/server/compiler/validators/skill-validator.js';
import { formatWarnings } from '../../src/server/compiler/validators/warning-formatter.js';
import type { ValidationContext } from '../../src/server/compiler/validators/types.js';
import type { ParsedTool, ParsedResource, ParsedPrompt, ParsedSkill } from '../../src/server/compiler/types.js';

/**
 * Helper to create a validation context for integration testing
 */
function createValidationContext(
  tools: ParsedTool[],
  resources: ParsedResource[],
  prompts: ParsedPrompt[],
  skills: ParsedSkill[],
  configOverrides?: any
): ValidationContext {
  return {
    tools: new Map(tools.map(t => [t.name, t])),
    resources: new Map(resources.map(r => [r.uri, r])),
    prompts: new Map(prompts.map(p => [p.name, p])),
    skills: new Map(skills.map(s => [s.name, s])),
    sourceFile: '/test/server.ts',
    config: {
      enabled: true,
      rules: {
        orphanedHidden: 'warn',
        invalidReferences: 'error',
        nonHiddenComponents: 'warn',
        emptySkills: 'warn'
      },
      strict: false,
      ...configOverrides
    }
  };
}

describe('Validation Pipeline Integration', () => {
  describe('Clean Server (No Warnings)', () => {
    it('should validate a properly configured server with no warnings', () => {
      const tools: ParsedTool[] = [
        {
          name: 'greet',
          methodName: 'greet',
          description: 'Greet user',
          hidden: false,
          params: {} as any,
          result: {} as any,
          interfaceName: 'GreetTool',
          location: { file: '/test/server.ts', line: 10 }
        },
        {
          name: 'debug_mode',
          methodName: 'debugMode',
          description: 'Debug',
          hidden: true,
          hiddenIsDynamic: false,
          params: {} as any,
          result: {} as any,
          interfaceName: 'DebugTool',
          location: { file: '/test/server.ts', line: 20 }
        }
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'debug_toolkit',
          description: 'Debug tools',
          isAutoGenerated: true,
          tools: [
            tools: ['debug_mode']
          },
          interfaceName: 'DebugSkill',
          location: { file: '/test/server.ts', line: 30 }
        }
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });
  });

  describe('Orphaned Hidden Items', () => {
    it('should detect orphaned hidden tool', () => {
      const tools: ParsedTool[] = [
        {
          name: 'orphaned_tool',
          methodName: 'orphanedTool',
          description: 'Orphaned',
          hidden: true,
          hiddenIsDynamic: false,
          params: {} as any,
          result: {} as any,
          interfaceName: 'OrphanedTool',
          location: { file: '/test/server.ts', line: 10 }
        }
      ];

      const context = createValidationContext(tools, [], [], []);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('orphaned-hidden-tool');
      expect(warnings[0].severity).toBe('warning');
      expect(warnings[0].message).toContain('orphaned_tool');

      // Test formatted output
      const formatted = formatWarnings(warnings);
      expect(formatted).toContain('Orphaned Hidden Tool');
      expect(formatted).toContain('⚠️');
      expect(formatted).toContain('WARNING');
    });

    it('should detect multiple orphaned items', () => {
      const tools: ParsedTool[] = [
        {
          name: 'tool1',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool
      ];

      const resources: ParsedResource[] = [
        {
          uri: 'config://hidden',
          name: 'Hidden Config',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedResource
      ];

      const prompts: ParsedPrompt[] = [
        {
          name: 'hidden_prompt',
          description: 'Hidden',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedPrompt
      ];

      const context = createValidationContext(tools, resources, prompts, []);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(3);
      expect(warnings.find(w => w.rule === 'orphaned-hidden-tool')).toBeDefined();
      expect(warnings.find(w => w.rule === 'orphaned-hidden-resource')).toBeDefined();
      expect(warnings.find(w => w.rule === 'orphaned-hidden-prompt')).toBeDefined();
    });
  });

  describe('Invalid Component References', () => {
    it('should detect invalid tool reference', () => {
      const tools: ParsedTool[] = [
        {
          name: 'existing_tool',
          methodName: 'existingTool'
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'test_skill',
          description: 'Test',
          isAutoGenerated: true,
          tools: [
            tools: ['nonexistent_tool']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('invalid-tool-reference');
      expect(warnings[0].severity).toBe('error');
      expect(warnings[0].message).toContain('nonexistent_tool');
      expect(warnings[0].suggestion).toContain('existing_tool');

      // Test formatted output
      const formatted = formatWarnings(warnings);
      expect(formatted).toContain('Invalid Tool Reference');
      expect(formatted).toContain('❌');
      expect(formatted).toContain('ERROR');
    });

    it('should detect mixed valid and invalid references', () => {
      const tools: ParsedTool[] = [
        {
          name: 'valid_tool',
          methodName: 'validTool',
          hidden: true // Make it hidden to avoid non-hidden-component warning
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'test_skill',
          tools: [
            tools: ['valid_tool', 'invalid1', 'invalid2']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(2); // Only invalid ones
      expect(warnings.every(w => w.rule === 'invalid-tool-reference')).toBe(true);
    });
  });

  describe('Non-Hidden Components', () => {
    it('should warn about skill referencing public tool', () => {
      const tools: ParsedTool[] = [
        {
          name: 'public_tool',
          methodName: 'publicTool',
          hidden: false
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'test_skill',
          tools: [
            tools: ['public_tool']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('non-hidden-component');
      expect(warnings[0].severity).toBe('warning');
      expect(warnings[0].message).toContain('public_tool');
      expect(warnings[0].message).toContain('not hidden');
    });

    it('should not warn about hidden components', () => {
      const tools: ParsedTool[] = [
        {
          name: 'hidden_tool',
          hidden: true
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'test_skill',
          tools: [
            tools: ['hidden_tool']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });
  });

  describe('Empty Skills', () => {
    it('should warn about auto-generated skill with no components', () => {
      const skills: ParsedSkill[] = [
        {
          name: 'empty_skill',
          description: 'Empty',
          isAutoGenerated: true,
          tools: [}
        } as ParsedSkill
      ];

      const context = createValidationContext([], [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].rule).toBe('empty-skill-components');
      expect(warnings[0].message).toContain('empty_skill');
    });

    it('should not warn about manual skills', () => {
      const skills: ParsedSkill[] = [
        {
          name: 'manual_skill',
          description: 'Manual',
          isAutoGenerated: false,
          tools: [}
        } as ParsedSkill
      ];

      const context = createValidationContext([], [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });
  });

  describe('Multiple Rule Violations', () => {
    it('should detect violations from multiple rules simultaneously', () => {
      const tools: ParsedTool[] = [
        {
          name: 'orphaned_hidden',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool,
        {
          name: 'public_tool',
          hidden: false
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'skill1',
          isAutoGenerated: true,
          tools: [
            tools: ['public_tool'] // Non-hidden component warning
          }
        } as ParsedSkill,
        {
          name: 'skill2',
          isAutoGenerated: true,
          tools: [
            tools: ['nonexistent'] // Invalid reference error
          }
        } as ParsedSkill,
        {
          name: 'skill3',
          isAutoGenerated: true,
          tools: [} // Empty skill warning
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);

      // Should have warnings from all 4 rules
      expect(warnings.length).toBeGreaterThanOrEqual(4);
      expect(warnings.find(w => w.rule === 'orphaned-hidden-tool')).toBeDefined();
      expect(warnings.find(w => w.rule === 'invalid-tool-reference')).toBeDefined();
      expect(warnings.find(w => w.rule === 'non-hidden-component')).toBeDefined();
      expect(warnings.find(w => w.rule === 'empty-skill-components')).toBeDefined();

      // Test formatted output groups them correctly
      const formatted = formatWarnings(warnings);
      expect(formatted).toContain('Orphaned Hidden Tool');
      expect(formatted).toContain('Invalid Tool Reference');
      expect(formatted).toContain('Non-Hidden Component');
      expect(formatted).toContain('Empty Skill Components');
      expect(formatted).toContain('Summary');
    });
  });

  describe('Configuration Integration', () => {
    it('should respect disabled validation', () => {
      const tools: ParsedTool[] = [
        {
          name: 'orphaned',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool
      ];

      const context = createValidationContext(tools, [], [], [], {
        enabled: false
      });

      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });

    it('should respect disabled individual rules', () => {
      const tools: ParsedTool[] = [
        {
          name: 'orphaned',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool,
        {
          name: 'public',
          hidden: false
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'test_skill',
          tools: [
            tools: ['public']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills, {
        rules: {
          orphanedHidden: 'off',
          nonHiddenComponents: 'off'
        }
      });

      const warnings = validateSkills(context);

      // Should have no warnings since both rules are disabled
      expect(warnings).toHaveLength(0);
    });

    it('should respect error severity configuration', () => {
      const tools: ParsedTool[] = [
        {
          name: 'orphaned',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool
      ];

      const context = createValidationContext(tools, [], [], [], {
        rules: {
          orphanedHidden: 'error'
        }
      });

      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(1);
      expect(warnings[0].severity).toBe('error');
    });
  });

  describe('Warning Formatting Integration', () => {
    it('should produce complete formatted output for complex scenario', () => {
      const tools: ParsedTool[] = [
        {
          name: 'orphaned1',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool,
        {
          name: 'orphaned2',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'skill1',
          isAutoGenerated: true,
          tools: [
            tools: ['nonexistent']
          }
        } as ParsedSkill,
        {
          name: 'skill2',
          isAutoGenerated: true,
          tools: [}
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);
      const formatted = formatWarnings(warnings);

      // Should have grouped sections
      expect(formatted).toContain('='.repeat(70));

      // Should have multiple rule sections
      expect(formatted).toContain('Orphaned Hidden Tool (2)');
      expect(formatted).toContain('Invalid Tool Reference');
      expect(formatted).toContain('Empty Skill Components');

      // Should have summary
      expect(formatted).toContain('Summary');
      expect(formatted).toMatch(/\d+ error/);
      expect(formatted).toMatch(/\d+ warning/);

      // Should have separators
      expect(formatted).toContain('─'.repeat(70));
    });

    it('should show success message when no warnings', () => {
      const tools: ParsedTool[] = [
        {
          name: 'hidden_tool',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'valid_skill',
          tools: [
            tools: ['hidden_tool']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);
      const warnings = validateSkills(context);
      const formatted = formatWarnings(warnings);

      expect(formatted).toContain('✓');
      expect(formatted).toContain('No skill validation warnings');
    });
  });

  describe('Performance', () => {
    it('should validate a large server quickly', () => {
      // Create a large server with many components
      const tools: ParsedTool[] = Array.from({ length: 50 }, (_, i) => ({
        name: `tool${i}`,
        methodName: `tool${i}`,
        hidden: i % 2 === 0,
        hiddenIsDynamic: false
      } as ParsedTool));

      const skills: ParsedSkill[] = Array.from({ length: 10 }, (_, i) => ({
        name: `skill${i}`,
        isAutoGenerated: true,
        tools: [
          tools: Array.from({ length: 5 }, (_, j) => `tool${i * 5 + j}`)
        }
      } as ParsedSkill));

      const context = createValidationContext(tools, [], [], skills);

      const startTime = performance.now();
      const warnings = validateSkills(context);
      const endTime = performance.now();

      const duration = endTime - startTime;

      // Should complete in under 100ms for large server
      expect(duration).toBeLessThan(100);

      // Should still detect issues
      expect(warnings.length).toBeGreaterThan(0);
    });

    it('should handle small server very quickly', () => {
      const tools: ParsedTool[] = [
        {
          name: 'tool1',
          hidden: true,
          hiddenIsDynamic: false
        } as ParsedTool
      ];

      const skills: ParsedSkill[] = [
        {
          name: 'skill1',
          tools: [
            tools: ['tool1']
          }
        } as ParsedSkill
      ];

      const context = createValidationContext(tools, [], [], skills);

      const startTime = performance.now();
      validateSkills(context);
      const endTime = performance.now();

      const duration = endTime - startTime;

      // Small server should be very fast
      expect(duration).toBeLessThan(10);
    });
  });

  describe('Edge Cases', () => {
    it('should handle completely empty server', () => {
      const context = createValidationContext([], [], [], []);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle server with only tools', () => {
      const tools: ParsedTool[] = [
        {
          name: 'tool1',
          hidden: false
        } as ParsedTool
      ];

      const context = createValidationContext(tools, [], [], []);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });

    it('should handle server with only skills', () => {
      const skills: ParsedSkill[] = [
        {
          name: 'skill1',
          isAutoGenerated: false
        } as ParsedSkill
      ];

      const context = createValidationContext([], [], [], skills);
      const warnings = validateSkills(context);

      expect(warnings).toHaveLength(0);
    });
  });
});
