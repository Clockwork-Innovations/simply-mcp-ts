/**
 * Test Helper: Compile Server From Code
 *
 * Helper function to compile inline TypeScript server code for testing.
 * Writes code to a temporary file, compiles it, and returns the result.
 */

import { compileInterfaceFile } from '../../src/server/compiler/index.js';
import { BuildMCPServer } from '../../src/server/builder-server.js';
import { writeFileSync, unlinkSync, mkdirSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { pathToFileURL } from 'url';
import type { ParseResult } from '../../src/server/compiler/types.js';

export interface CompileOptions {
  name: string;
  version: string;
  silent?: boolean;
}

export interface CompileResult {
  server: BuildMCPServer;
  parsed: ParseResult;
}

/**
 * Compile inline TypeScript server code for testing
 *
 * @param code - TypeScript server code
 * @param options - Compilation options
 * @returns Compiled server and parse result
 *
 * @example
 * const { server, parsed } = await compileServerFromCode(code, {
 *   name: 'test',
 *   version: '1.0.0',
 *   silent: true
 * });
 *
 * const interfaceServer = server.toInterfaceServer();
 * const tools = await interfaceServer.listTools({});
 */
export async function compileServerFromCode(
  code: string,
  options: CompileOptions
): Promise<CompileResult> {
  const { name, version, silent = false } = options;

  // Create temp directory if it doesn't exist
  const testDir = join(tmpdir(), 'simply-mcp-test-' + Date.now());
  mkdirSync(testDir, { recursive: true });

  // Create temp file
  const testFile = join(testDir, 'test-server.ts');
  writeFileSync(testFile, code);

  try {
    // Compile the interface file
    const parsed = await compileInterfaceFile(testFile, {
      validation: {
        enabled: true,
        rules: {
          orphanedHidden: 'warn',
          invalidReferences: 'error',
          nonHiddenComponents: 'warn',
          emptySkills: 'warn'
        },
        strict: false
      }
    });

    if (!silent && parsed.validation?.warnings && parsed.validation.warnings.length > 0) {
      console.log(`[Compile] ${parsed.validation.warnings.length} validation warnings`);
    }

    // Load the compiled module using dynamic import
    const fileUrl = pathToFileURL(testFile).href;
    const moduleUrl = `${fileUrl}?t=${Date.now()}`;
    const module = await import(moduleUrl);

    // Get the default export (server class or instance)
    let ServerClass = module.default;

    // Handle CommonJS bundles
    if (ServerClass && typeof ServerClass === 'object' && ServerClass.default) {
      ServerClass = ServerClass.default;
    }

    // Instantiate if it's a class, otherwise use as-is
    const moduleInstance = typeof ServerClass === 'function' ? new ServerClass() : ServerClass;

    // Create server
    const builder = new BuildMCPServer({ name, version });

    // Register tools
    for (const tool of parsed.tools || []) {
      const handler = moduleInstance[tool.methodName];
      if (handler) {
        builder.addTool({
          name: tool.name,
          description: tool.description,
          hidden: tool.hidden,
          hiddenIsDynamic: tool.hiddenIsDynamic,
          schema: tool.params,
          handler
        });
      }
    }

    // Register resources
    for (const resource of parsed.resources || []) {
      const handler = moduleInstance[resource.methodName];
      if (handler) {
        builder.addResource({
          uri: resource.uri,
          name: resource.name,
          description: resource.description,
          mimeType: resource.mimeType,
          hidden: resource.hidden,
          hiddenIsDynamic: resource.hiddenIsDynamic,
          handler
        });
      }
    }

    // Register prompts
    for (const prompt of parsed.prompts || []) {
      const handler = moduleInstance[prompt.methodName];
      if (handler) {
        builder.addPrompt({
          name: prompt.name,
          description: prompt.description,
          schema: prompt.args,
          hidden: prompt.hidden,
          hiddenIsDynamic: prompt.hiddenIsDynamic,
          handler
        });
      }
    }

    // Register skills
    for (const skill of parsed.skills || []) {
      const handler = moduleInstance[skill.methodName];
      if (handler) {
        builder.addSkill({
          name: skill.name,
          description: skill.description,
          hidden: skill.hidden,
          hiddenIsDynamic: skill.hiddenIsDynamic,
          isAutoGenerated: skill.isAutoGenerated,
          components: skill.components,
          handler
        });
      }
    }

    return { server: builder, parsed };
  } finally {
    // Clean up temp file
    try {
      unlinkSync(testFile);
    } catch (err) {
      // Ignore cleanup errors
    }
  }
}
