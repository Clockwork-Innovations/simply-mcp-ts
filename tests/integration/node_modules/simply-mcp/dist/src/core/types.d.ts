/**
 * Core type definitions for the Handler Execution Framework
 */
/**
 * Base interface for all handler configurations
 */
export interface BaseHandlerConfig {
    type: 'inline' | 'file' | 'http' | 'registry';
}
/**
 * Inline handler configuration - executes JavaScript code strings
 */
export interface InlineHandlerConfig extends BaseHandlerConfig {
    type: 'inline';
    code: string;
    timeout?: number;
}
/**
 * File handler configuration - loads and executes modules from filesystem
 */
export interface FileHandlerConfig extends BaseHandlerConfig {
    type: 'file';
    path: string;
    export?: string;
}
/**
 * HTTP handler configuration - makes HTTP requests to external services
 */
export interface HttpHandlerConfig extends BaseHandlerConfig {
    type: 'http';
    url: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE';
    headers?: Record<string, string>;
    timeout?: number;
    retries?: number;
    requestTransform?: string;
    responseTransform?: string;
}
/**
 * Registry handler configuration - looks up pre-registered handlers
 */
export interface RegistryHandlerConfig extends BaseHandlerConfig {
    type: 'registry';
    name: string;
}
/**
 * Union type of all handler configurations
 */
export type HandlerConfig = InlineHandlerConfig | FileHandlerConfig | HttpHandlerConfig | RegistryHandlerConfig;
/**
 * Context provided to handlers during execution
 */
export interface HandlerContext {
    sessionId?: string;
    logger: Logger;
    permissions?: Permissions;
    metadata?: Record<string, unknown>;
    /**
     * Request an LLM completion from the client.
     * Only available when the client supports sampling capability.
     * @param messages Array of messages for the LLM
     * @param options Optional sampling parameters (maxTokens, temperature, etc.)
     * @returns The LLM's response (type from MCP SDK)
     */
    sample?: (messages: SamplingMessage[], options?: SamplingOptions) => Promise<any>;
    /**
     * Send a progress notification to the client.
     * Only available when the request includes a progressToken.
     * @param progress Current progress value
     * @param total Optional total value (for percentage calculation)
     * @param message Optional progress message
     */
    reportProgress?: (progress: number, total?: number, message?: string) => Promise<void>;
    /**
     * Read a resource by URI.
     * Only available when the server has resources registered.
     * @param uri The resource URI to read
     * @returns The resource contents
     */
    readResource?: (uri: string) => Promise<ResourceContents>;
}
/**
 * Sampling message for LLM completion requests
 * Simplified wrapper around MCP SDK types
 */
export interface SamplingMessage {
    role: 'user' | 'assistant';
    content: {
        type: string;
        text?: string;
        data?: string;
        mimeType?: string;
        [key: string]: unknown;
    };
}
/**
 * Options for sampling/LLM completion
 */
export interface SamplingOptions {
    maxTokens?: number;
    temperature?: number;
    topP?: number;
    topK?: number;
    stopSequences?: string[];
    metadata?: Record<string, unknown>;
    [key: string]: unknown;
}
/**
 * Resource contents returned from readResource
 */
export interface ResourceContents {
    uri: string;
    mimeType: string;
    text?: string;
    blob?: string;
}
/**
 * Logger interface for handler execution
 */
export interface Logger {
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string, ...args: unknown[]): void;
    notice?(message: string, ...args: unknown[]): void;
    critical?(message: string, ...args: unknown[]): void;
    alert?(message: string, ...args: unknown[]): void;
    emergency?(message: string, ...args: unknown[]): void;
}
/**
 * Permission settings for handler execution
 */
export interface Permissions {
    allowFileSystem?: boolean;
    allowNetwork?: boolean;
    allowedPaths?: string[];
    allowedDomains?: string[];
}
/**
 * Image content for handler results
 */
export interface ImageContent {
    type: 'image';
    data: string;
    mimeType: string;
    _meta?: object;
}
/**
 * Audio content for handler results
 */
export interface AudioContent {
    type: 'audio';
    data: string;
    mimeType: string;
    _meta?: object;
}
/**
 * Binary content for handler results
 */
export interface BinaryContent {
    type: 'binary';
    data: string;
    mimeType: string;
    _meta?: object;
}
/**
 * Text content for handler results
 */
export interface TextContent {
    type: 'text';
    text: string;
    [key: string]: unknown;
}
/**
 * Result returned by handler execution
 */
export interface HandlerResult {
    content: Array<TextContent | ImageContent | AudioContent | BinaryContent>;
    metadata?: Record<string, unknown>;
    errors?: HandlerError[];
    [key: string]: unknown;
}
/**
 * Error information from handler execution
 */
export interface HandlerError {
    code: string;
    message: string;
    stack?: string;
    details?: Record<string, unknown>;
}
/**
 * Function signature for tool handlers
 */
export type ToolHandler = (args: Record<string, unknown>, context: HandlerContext) => Promise<HandlerResult>;
/**
 * Abstract interface for handler resolvers
 */
export interface HandlerResolver {
    /**
     * Resolve a handler configuration to an executable function
     * @param config Handler configuration
     * @returns Executable tool handler function
     */
    resolve(config: HandlerConfig): Promise<ToolHandler>;
    /**
     * Check if this resolver can handle the given configuration
     * @param config Handler configuration
     * @returns True if this resolver supports the config type
     */
    canResolve(config: HandlerConfig): boolean;
}
/**
 * Options for handler execution
 */
export interface HandlerExecutionOptions {
    timeout?: number;
    retries?: number;
    abortSignal?: AbortSignal;
}
//# sourceMappingURL=types.d.ts.map