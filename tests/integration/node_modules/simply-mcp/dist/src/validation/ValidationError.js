/**
 * ValidationError.ts
 * Custom error classes for validation and sanitization failures
 *
 * Usage:
 * ```typescript
 * throw new ValidationError('Invalid input', 'username', 'string', 123);
 * throw new SchemaValidationError(zodError);
 * throw new SanitizationError('SQL injection detected', 'query');
 * ```
 */
/**
 * Base validation error class
 */
export class ValidationError extends Error {
    isValidationError = true;
    field;
    expected;
    actual;
    details;
    constructor(message, field, expected, actual, details) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
        this.expected = expected;
        this.actual = actual;
        this.details = details || (field ? [{
                field,
                message,
                expected,
                actual,
            }] : []);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ValidationError);
        }
    }
    /**
     * Format error for JSON-RPC response
     */
    toJsonRpc() {
        return {
            code: -32602, // Invalid params
            message: this.message,
            data: {
                validationErrors: this.details,
            },
        };
    }
    /**
     * Get a user-friendly error message
     */
    getUserMessage() {
        if (this.details.length === 1) {
            const detail = this.details[0];
            return `${detail.field}: ${detail.message}`;
        }
        return `${this.message} (${this.details.length} validation errors)`;
    }
}
/**
 * Schema validation error (wraps Zod errors)
 */
export class SchemaValidationError extends ValidationError {
    zodError;
    constructor(zodError, context) {
        const details = SchemaValidationError.parseZodError(zodError);
        const message = context
            ? `Schema validation failed for ${context}`
            : 'Schema validation failed';
        super(message, undefined, undefined, undefined, details);
        this.name = 'SchemaValidationError';
        this.zodError = zodError;
    }
    /**
     * Parse Zod error into our ValidationErrorDetail format
     */
    static parseZodError(zodError) {
        return zodError.issues.map((issue) => {
            const field = issue.path.join('.');
            return {
                field: field || 'root',
                message: issue.message,
                code: issue.code,
                expected: this.getExpectedType(issue),
                actual: undefined, // Zod doesn't always provide the actual value
            };
        });
    }
    /**
     * Extract expected type from Zod issue
     */
    static getExpectedType(issue) {
        switch (issue.code) {
            case 'invalid_type':
                return issue.expected;
            case 'too_small':
                return `minimum ${issue.minimum}`;
            case 'too_big':
                return `maximum ${issue.maximum}`;
            default:
                // For other types, try to extract useful info
                if ('expected' in issue) {
                    return String(issue.expected);
                }
                return undefined;
        }
    }
}
/**
 * Sanitization error
 */
export class SanitizationError extends Error {
    isSanitizationError = true;
    field;
    reason;
    dangerous;
    constructor(message, field, reason, dangerous) {
        super(message);
        this.name = 'SanitizationError';
        this.field = field;
        this.reason = reason || message;
        this.dangerous = dangerous;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, SanitizationError);
        }
    }
    /**
     * Format error for JSON-RPC response
     */
    toJsonRpc() {
        return {
            code: -32602, // Invalid params
            message: this.message,
            data: {
                field: this.field,
                reason: this.reason,
                dangerous: this.dangerous ? '[REDACTED]' : undefined,
            },
        };
    }
}
/**
 * Type guard for ValidationError
 */
export function isValidationError(error) {
    return error && error.isValidationError === true;
}
/**
 * Type guard for SanitizationError
 */
export function isSanitizationError(error) {
    return error && error.isSanitizationError === true;
}
/**
 * Convert any error to JSON-RPC format
 */
export function errorToJsonRpc(error) {
    if (isValidationError(error) || isSanitizationError(error)) {
        return error.toJsonRpc();
    }
    // Generic error
    return {
        code: -32603, // Internal error
        message: error.message || 'An unknown error occurred',
    };
}
//# sourceMappingURL=ValidationError.js.map