/**
 * Schema Builder - Convert TypeScript-like schema definitions to Zod
 *
 * This provides a cleaner, more declarative way to define parameter schemas
 * without directly using Zod syntax in config files.
 */
import { z } from 'zod';
/**
 * Convert a schema definition to a Zod schema
 */
export function schemaToZod(schema) {
    let zodSchema;
    switch (schema.type) {
        case 'string':
            zodSchema = z.string();
            if (schema.minLength !== undefined) {
                zodSchema = zodSchema.min(schema.minLength);
            }
            if (schema.maxLength !== undefined) {
                zodSchema = zodSchema.max(schema.maxLength);
            }
            if (schema.pattern) {
                const pattern = schema.pattern;
                zodSchema = zodSchema.regex(pattern instanceof RegExp ? pattern : new RegExp(pattern));
            }
            break;
        case 'email':
            zodSchema = z.string().email();
            break;
        case 'url':
            zodSchema = z.string().url();
            break;
        case 'uuid':
            zodSchema = z.string().uuid();
            break;
        case 'number':
            zodSchema = z.number();
            if (schema.int) {
                zodSchema = zodSchema.int();
            }
            if (schema.min !== undefined) {
                zodSchema = zodSchema.min(schema.min);
            }
            if (schema.max !== undefined) {
                zodSchema = zodSchema.max(schema.max);
            }
            break;
        case 'boolean':
            zodSchema = z.boolean();
            break;
        case 'enum':
            const enumValues = schema.values;
            zodSchema = z.enum(enumValues);
            break;
        case 'array':
            const arraySchema = schema;
            const itemSchema = schemaToZod(arraySchema.items);
            zodSchema = z.array(itemSchema);
            if (arraySchema.minItems !== undefined) {
                zodSchema = zodSchema.min(arraySchema.minItems);
            }
            if (arraySchema.maxItems !== undefined) {
                zodSchema = zodSchema.max(arraySchema.maxItems);
            }
            break;
        case 'object':
            const objSchema = schema;
            const shape = {};
            for (const [key, propSchema] of Object.entries(objSchema.properties)) {
                shape[key] = schemaToZod(propSchema);
            }
            zodSchema = z.object(shape);
            break;
        case 'date':
            zodSchema = z.date();
            break;
        default:
            throw new Error(`Unsupported schema type: ${schema.type}`);
    }
    // Add description if provided
    if (schema.description) {
        zodSchema = zodSchema.describe(schema.description);
    }
    // Make optional if specified
    if (schema.optional) {
        zodSchema = zodSchema.optional();
    }
    // Add default value if specified
    if (schema.default !== undefined) {
        zodSchema = zodSchema.default(schema.default);
    }
    return zodSchema;
}
/**
 * Helper function to create a schema object from properties
 */
export function createSchema(properties, required) {
    return {
        type: 'object',
        properties,
        required,
    };
}
/**
 * Shorthand builders for common types
 */
export const Schema = {
    string: (options) => ({
        type: 'string',
        ...options,
    }),
    email: (options) => ({
        type: 'email',
        ...options,
    }),
    url: (options) => ({
        type: 'url',
        ...options,
    }),
    uuid: (options) => ({
        type: 'uuid',
        ...options,
    }),
    number: (options) => ({
        type: 'number',
        ...options,
    }),
    int: (options) => ({
        type: 'number',
        int: true,
        ...options,
    }),
    boolean: (options) => ({
        type: 'boolean',
        ...options,
    }),
    enum: (values, options) => ({
        type: 'enum',
        values,
        ...options,
    }),
    array: (items, options) => ({
        type: 'array',
        items,
        ...options,
    }),
    object: (properties, options) => ({
        type: 'object',
        properties,
        ...options,
    }),
    date: (options) => ({
        type: 'date',
        ...options,
    }),
};
//# sourceMappingURL=schema-builder.js.map