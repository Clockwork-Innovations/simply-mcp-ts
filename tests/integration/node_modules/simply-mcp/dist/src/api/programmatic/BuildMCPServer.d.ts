/**
 * BuildMCPServer - Programmatic API for building MCP servers
 *
 * A builder-pattern class for creating MCP servers programmatically.
 * Use this when you want explicit control over server configuration.
 *
 * @example
 * ```typescript
 * import { BuildMCPServer } from 'simply-mcp';
 * import { z } from 'zod';
 *
 * const server = new BuildMCPServer({
 *   name: 'my-server',
 *   version: '1.0.0'
 * });
 *
 * server.addTool({
 *   name: 'greet',
 *   description: 'Greet a user',
 *   parameters: z.object({
 *     name: z.string(),
 *   }),
 *   execute: async (args) => {
 *     return `Hello, ${args.name}!`;
 *   },
 * });
 *
 * await server.start();
 * ```
 */
import { ParsedDependencies } from '../../core/index.js';
import { InstallOptions, InstallResult, DependencyStatus } from '../../features/dependencies/installation-types.js';
import type { ToolDefinition, PromptDefinition, ResourceDefinition, BuildMCPServerOptions, StartOptions, InternalTool } from './types.js';
/**
 * BuildMCPServer - A programmatic API for creating MCP servers
 */
export declare class BuildMCPServer {
    private options;
    private tools;
    private prompts;
    private resources;
    private handlerManager;
    private server?;
    private httpServer?;
    private transports;
    private isRunning;
    private dependencies?;
    /**
     * Create a new BuildMCPServer
     */
    constructor(options: BuildMCPServerOptions);
    /**
     * Get the server name (BUG-004 FIX)
     */
    get name(): string;
    /**
     * Get the server version (BUG-004 FIX)
     */
    get version(): string;
    /**
     * Get the server description (additional getter)
     */
    get description(): string | undefined;
    /**
     * Add a tool to the server
     * @param definition Tool definition with Zod schema and execute function
     * @returns this for chaining
     */
    addTool<T = any>(definition: ToolDefinition<T>): this;
    /**
     * Add a prompt to the server
     * @param definition Prompt definition
     * @returns this for chaining
     */
    addPrompt(definition: PromptDefinition): this;
    /**
     * Add a resource to the server
     * @param definition Resource definition
     * @returns this for chaining
     */
    addResource(definition: ResourceDefinition): this;
    /**
     * Start the server
     * @param options Start options (overrides configuration from constructor)
     */
    start(options?: StartOptions): Promise<void>;
    /**
     * Stop the server gracefully
     */
    stop(): Promise<void>;
    /**
     * Register tool handlers with the MCP server
     */
    private registerToolHandlers;
    /**
     * Register prompt handlers with the MCP server
     */
    private registerPromptHandlers;
    /**
     * Register resource handlers with the MCP server
     */
    private registerResourceHandlers;
    /**
     * Start the server with stdio transport
     */
    private startStdio;
    /**
     * Start the server with HTTP transport
     */
    private startHttp;
    /**
     * Render a template string with variables
     */
    private renderTemplate;
    /**
     * Normalize result to HandlerResult format
     * Handles text, binary content (Buffer/Uint8Array), and structured objects
     */
    private normalizeResult;
    /**
     * Get server info
     */
    getInfo(): {
        name: string;
        version: string;
        isRunning: boolean;
    };
    /**
     * Get statistics about registered items
     */
    getStats(): {
        tools: number;
        prompts: number;
        resources: number;
    };
    /**
     * Get inline dependencies
     * Returns parsed dependencies if available
     *
     * @returns Parsed dependencies or null if none declared
     *
     * @example
     * ```typescript
     * const deps = server.getDependencies();
     * if (deps) {
     *   console.log('Dependencies:', deps.map);
     * }
     * ```
     */
    getDependencies(): ParsedDependencies | null;
    /**
     * Check if a specific dependency is declared
     *
     * @param packageName - Package name to check
     * @returns True if dependency is declared
     *
     * @example
     * ```typescript
     * if (server.hasDependency('axios')) {
     *   console.log('Server uses axios');
     * }
     * ```
     */
    hasDependency(packageName: string): boolean;
    /**
     * Get version specifier for a specific package
     *
     * @param packageName - Package name to lookup
     * @returns Version specifier or undefined if not declared
     *
     * @example
     * ```typescript
     * const version = server.getDependencyVersion('axios');
     * console.log(`axios version: ${version}`);
     * ```
     */
    getDependencyVersion(packageName: string): string | undefined;
    /**
     * Install missing dependencies
     *
     * @param options - Installation options
     * @returns Installation result
     *
     * @example
     * ```typescript
     * const result = await server.installDependencies({
     *   packageManager: 'npm',
     *   timeout: 10 * 60 * 1000, // 10 minutes
     *   onProgress: (event) => {
     *     console.log(`${event.type}: ${event.message}`);
     *   }
     * });
     *
     * if (result.success) {
     *   console.log(`Installed: ${result.installed.join(', ')}`);
     * } else {
     *   console.error(`Errors: ${result.errors.length}`);
     * }
     * ```
     */
    installDependencies(options?: InstallOptions): Promise<InstallResult>;
    /**
     * Check dependency status (installed vs missing)
     *
     * @returns Dependency check result
     *
     * @example
     * ```typescript
     * const status = await server.checkDependencies();
     * console.log(`Missing: ${status.missing.join(', ')}`);
     * console.log(`Installed: ${status.installed.join(', ')}`);
     * ```
     */
    checkDependencies(): Promise<DependencyStatus>;
    /**
     * Create BuildMCPServer from file with inline dependencies
     * Parses the file content to extract inline dependency declarations
     *
     * @param filePath - Path to server file
     * @param options - Additional server options (will override parsed values)
     * @returns Promise resolving to BuildMCPServer instance
     *
     * @example
     * ```typescript
     * // Without auto-install (default)
     * const server = await BuildMCPServer.fromFile('./server.ts');
     *
     * // With auto-install
     * const server = await BuildMCPServer.fromFile('./server.ts', {
     *   autoInstall: true
     * });
     *
     * // With custom install options
     * const server = await BuildMCPServer.fromFile('./server.ts', {
     *   autoInstall: {
     *     packageManager: 'pnpm',
     *     onProgress: (event) => console.log(event.message)
     *   }
     * });
     * ```
     */
    static fromFile(filePath: string, options?: Partial<BuildMCPServerOptions>): Promise<BuildMCPServer>;
    /**
     * Request LLM sampling/completion from the client
     * @private
     */
    private requestSampling;
    /**
     * Send progress notification to the client
     * @private
     */
    private sendProgressNotification;
    /**
     * Send logging notification to the client
     * @private
     */
    private sendLoggingNotification;
    /**
     * Read a resource by URI (for use in handler context)
     * @private
     */
    private readResourceByUri;
    /**
     * Get all registered tools
     * @returns Map of tool names to internal tool definitions
     */
    getTools(): Map<string, InternalTool>;
    /**
     * Get all registered prompts
     * @returns Map of prompt names to prompt definitions
     */
    getPrompts(): Map<string, PromptDefinition>;
    /**
     * Get all registered resources
     * @returns Map of resource URIs to resource definitions
     */
    getResources(): Map<string, ResourceDefinition>;
    /**
     * Execute a tool directly (without going through MCP protocol)
     * @param toolName Name of the tool to execute
     * @param args Arguments for the tool
     * @returns Tool execution result
     */
    executeToolDirect(toolName: string, args: any): Promise<any>;
    /**
     * Get a prompt directly (without going through MCP protocol)
     * @param promptName Name of the prompt
     * @param args Arguments for the prompt
     * @returns Prompt result with rendered template
     */
    getPromptDirect(promptName: string, args?: any): Promise<any>;
    /**
     * Read a resource directly (without going through MCP protocol)
     * @param uri URI of the resource
     * @returns Resource contents
     */
    readResourceDirect(uri: string): Promise<any>;
}
//# sourceMappingURL=BuildMCPServer.d.ts.map